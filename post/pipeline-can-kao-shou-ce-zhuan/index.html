<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    pipeline参考手册「转] | zootopia的后花园
</title>
<link rel="shortcut icon" href="http://wangqunsong.github.io/favicon.ico?v=1569401796045">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://wangqunsong.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="http://wangqunsong.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="http://wangqunsong.github.io">
                <img class="avatar" src="http://wangqunsong.github.io/images/avatar.png?v=1569401796045" alt="">
            </a>
            <div class="site-title">
                <h1>
                    zootopia的后花园
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="http://wangqunsong.github.io" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="http://wangqunsong.github.io/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="http://wangqunsong.github.io/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            pipeline参考手册「转]
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2018-06-07</time>
                            
                                <a href="http://wangqunsong.github.io/tag/AZvxNNEdR" class="post-tag i-tag
                            i-tag-info">
                            #CI/CD
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>pipeline参考手册「转]</strong></p>
<!-- more --> 
<h2 id="一-写在前面">一、写在前面</h2>
<p>本pipeline中文版参考手册译者为<a href="https://testerhome.com/cay">TesterHome@cay</a>，所有权归原译者所有。</p>
<p>英语好的建议直接移步官网阅读：<a href="https://jenkins.io/doc/book/pipeline/">Jenkins pipeline</a></p>
<h2 id="二-语法简介">二、语法简介</h2>
<p>Pipeline最基本的部分是“step”。基本上，step告诉Jenkins 要做什么，并且作为Declarative Pipeline和Scripted Pipeline语法的基本构建块。<br>
Pipeline支持两种语法：Declarative Pipeline（在Pipeline 2.5中引入，结构化方式）和Scripted Pipeline，两者都支持建立连续输送的Pipeline。<br>
为与BlueOcean脚本编辑器兼容，通常建议使用Declarative Pipeline的方式进行编写,从jenkins社区的动向来看，很明显这种语法结构也会是未来的趋势。</p>
<h2 id="三-declarative-pipeline">三、Declarative Pipeline</h2>
<p>Declarative Pipeline是Jenkins Pipeline 的一个相对较新的补充， 它在Pipeline子系统之上提出了一种更为简化和有意义的语法。<br>
所有有效的Declarative Pipeline必须包含在一个pipeline块内，例如：<br>
pipeline { /* insert Declarative Pipeline here */ }<br>
Declarative Pipeline中的基本语句和表达式遵循与Groovy语法相同的规则 ，但有以下例外：<br>
a.Pipeline的顶层必须是块，具体来说是：pipeline { }<br>
b.没有分号作为语句分隔符。每个声明必须在自己的一行<br>
c.块只能包含Sections, Directives, Steps或赋值语句。<br>
d.属性引用语句被视为无参方法调用。所以例如，输入被视为input（）</p>
<h3 id="1sections章节">1.Sections（章节）</h3>
<p>Declarative Pipeline里的Sections通常包含一个或多个Directives或 Steps</p>
<h4 id="agent">agent</h4>
<p>该agent部分指定整个Pipeline或特定阶段将在Jenkins环境中执行的位置，具体取决于该agent 部分的放置位置。该部分必须在pipeline块内的顶层定义 ，但stage级使用是可选的。</p>
<figure data-type="image" tabindex="1"><a href="https://testerhome.com/uploads/photo/2017/b4ca18e6-8aa8-44a1-a420-cd055dbc5be6.png!large"><img src="https://testerhome.com/uploads/photo/2017/b4ca18e6-8aa8-44a1-a420-cd055dbc5be6.png!large" alt="img"></a></figure>
<p>参数</p>
<pre><code>docker
agent {
    docker {
        image 'maven:3-alpine'
        label 'my-defined-label'
        args  '-v /tmp:/tmp'
    }
}
</code></pre>
<p>dockerfile<br>
使用从Dockerfile源存储库中包含的容器来构建执行Pipeline或stage 。为了使用此选项，Jenkinsfile必须从Multibranch Pipeline或“Pipeline from SCM&quot;加载。<br>
默认是在Dockerfile源库的根目录：agent { dockerfile true }。如果Dockerfile需在另一个目录中建立，请使用以下dir选项：agent { dockerfile { dir 'someSubDir' } }。您可以通过docker build ...使用additionalBuildArgs选项，如agent { dockerfile { additionalBuildArgs '--build-arg foo=bar' } }。<br>
<strong>常用选项</strong><br>
这些是可以应用于两个或多个agent的选项。除非明确定义，否则不需要。<br>
label<br>
一个字符串。标记在哪里运行pipeline或stage<br>
此选项适用于node，docker和dockerfile，并且 node是必需的。<br>
customWorkspace<br>
一个字符串。自定义运行的工作空间内。它可以是相对路径，在这种情况下，自定义工作区将位于节点上的工作空间根目录下，也可以是绝对路径。例如：</p>
<pre><code>customWorkspace
agent {
    node {
        label 'my-defined-label'
        customWorkspace '/some/other/path'
    }
}
</code></pre>
<p>reuseNode<br>
一个布尔值，默认为false。如果为true，则在同一工作空间中。<br>
此选项适用于docker和dockerfile，并且仅在 individual stage中使用agent才有效。<br>
<strong>Example</strong></p>
<pre><code>Jenkinsfile (Declarative Pipeline)
pipeline {
    //Execute all the steps defined in this Pipeline within a newly created container of the given name and tag (maven:3-alpine).
    agent { docker 'maven:3-alpine' } 
    stages {
        stage('Example Build') {
            steps {
                sh 'mvn -B clean verify'
            }
        }
    }
}
</code></pre>
<pre><code>Stage-level agent section
pipeline {
    agent none 
    stages {
        stage('Example Build') {
            agent { docker 'maven:3-alpine' } 
            steps {
                echo 'Hello, Maven'
                sh 'mvn --version'
            }
        }
        stage('Example Test') {
            agent { docker 'openjdk:8-jre' } 
            steps {
                echo 'Hello, JDK'
                sh 'java -version'
            }
        }
    }
}
</code></pre>
<h4 id="post">post</h4>
<p>定义Pipeline或stage运行结束时的操作。post-condition块支持post部件：always，changed，failure，success，unstable，和aborted。这些块允许在Pipeline或stage运行结束时执行步骤，具体取决于Pipeline的状态。</p>
<figure data-type="image" tabindex="2"><a href="https://testerhome.com/uploads/photo/2017/d0548c42-0ee4-435c-844d-fc9969735cc8.png!large"><img src="https://testerhome.com/uploads/photo/2017/d0548c42-0ee4-435c-844d-fc9969735cc8.png!large" alt="img"></a></figure>
<p>conditions项：</p>
<p><strong>Example</strong></p>
<pre><code>post
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
    post { 
        always { 
            echo 'I will always say Hello again!'
        }
    }
}
</code></pre>
<h4 id="stages">stages</h4>
<p>包含一个或多个stage的序列，Pipeline的大部分工作在此执行。建议stages至少包含至少一个stage指令，用于连接各个交付过程，如构建，测试和部署等。</p>
<figure data-type="image" tabindex="3"><a href="https://testerhome.com/uploads/photo/2017/be8f539b-1b8e-41c4-9ea9-a909041385a3.png!large"><img src="https://testerhome.com/uploads/photo/2017/be8f539b-1b8e-41c4-9ea9-a909041385a3.png!large" alt="img"></a></figure>
<h4 id="steps">steps</h4>
<p>steps包含一个或多个在stage块中执行的step序列。</p>
<figure data-type="image" tabindex="4"><a href="https://testerhome.com/uploads/photo/2017/19f88fdb-c8fa-448b-8a2f-0f8c2e73c746.png!large"><img src="https://testerhome.com/uploads/photo/2017/19f88fdb-c8fa-448b-8a2f-0f8c2e73c746.png!large" alt="img"></a></figure>
<p><strong>Example</strong></p>
<pre><code>stages
pipeline {
    agent any
    stages { 
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
</code></pre>
<h3 id="2directives-指令">2.Directives （指令）</h3>
<h4 id="environment">environment</h4>
<p>environment指令指定一系列键值对，这些键值对将被定义为所有step或stage-specific step的环境变量，具体取决于environment指令在Pipeline中的位置。<br>
该指令支持一种特殊的方法credentials()，可以通过其在Jenkins环境中的标识符来访问预定义的凭据。<br>
对于类型为“Secret Text”的凭据，该 credentials()方法将确保指定的环境变量包含Secret Text内容；对于“标准用户名和密码”类型的凭证，指定的环境变量将被设置为username:password。</p>
<figure data-type="image" tabindex="5"><a href="https://testerhome.com/uploads/photo/2017/61e1a1c8-ccaf-4e17-95a2-cf0fc874befb.png!large"><img src="https://testerhome.com/uploads/photo/2017/61e1a1c8-ccaf-4e17-95a2-cf0fc874befb.png!large" alt="img"></a></figure>
<p><strong>Example</strong></p>
<pre><code>environment
pipeline {
    agent any
    environment { 
        CC = 'clang'
    }
    stages {
        stage('Example') {
            environment { 
                AN_ACCESS_KEY = credentials('my-prefined-secret-text') 
            }
            steps {
                sh 'printenv'
            }
        }
    }
}
</code></pre>
<h4 id="options">options</h4>
<p>options指令允许在Pipeline本身内配置Pipeline专用选项。Pipeline本身提供了许多选项，例如buildDiscarder，但它们也可能由插件提供，例如 timestamps。</p>
<figure data-type="image" tabindex="6"><a href="https://testerhome.com/uploads/photo/2017/62df009a-9155-4db0-b164-2cda48a08b81.png!large"><img src="https://testerhome.com/uploads/photo/2017/62df009a-9155-4db0-b164-2cda48a08b81.png!large" alt="img"></a></figure>
<p><strong>可用选项</strong><br>
buildDiscarder<br>
pipeline保持构建的最大个数。例如：options { buildDiscarder(logRotator(numToKeepStr: '1')) }<br>
disableConcurrentBuilds<br>
不允许并行执行Pipeline,可用于防止同时访问共享资源等。例如：options { disableConcurrentBuilds() }<br>
skipDefaultCheckout<br>
默认跳过来自源代码控制的代码。例如：options { skipDefaultCheckout() }<br>
skipStagesAfterUnstable<br>
一旦构建状态进入了“Unstable”状态，就跳过此stage。例如：options { skipStagesAfterUnstable() }<br>
timeout<br>
设置Pipeline运行的超时时间。例如：options { timeout(time: 1, unit: 'HOURS') }<br>
retry<br>
失败后，重试整个Pipeline的次数。例如：options { retry(3) }<br>
timestamps<br>
预定义由Pipeline生成的所有控制台输出时间。例如：options { timestamps() }</p>
<p><strong>Example</strong></p>
<pre><code>options
pipeline {
    agent any
    options {
        timeout(time: 1, unit: 'HOURS') 
    }
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
</code></pre>
<h4 id="parameters">parameters</h4>
<p>parameters指令提供用户在触发Pipeline时的参数列表。这些参数值通过该params对象可用于Pipeline步骤，具体用法如下</p>
<figure data-type="image" tabindex="7"><a href="https://testerhome.com/uploads/photo/2017/a063f9e2-a6c6-41ea-b121-e1fc99acb112.png!large"><img src="https://testerhome.com/uploads/photo/2017/a063f9e2-a6c6-41ea-b121-e1fc99acb112.png!large" alt="img"></a></figure>
<p><strong>可用参数</strong><br>
string<br>
A parameter of a string type, for example: parameters { string(name: 'DEPLOY_ENV', defaultValue: 'staging', description: '') }<br>
booleanParam<br>
A boolean parameter, for example: parameters { booleanParam(name: 'DEBUG_BUILD', defaultValue: true, description: '') }<br>
目前只支持[booleanParam, choice, credentials, file, text, password, run, string]这几种参数类型，其他高级参数化类型还需等待社区支持。<br>
<strong>Example</strong></p>
<pre><code>params
pipeline {
    agent any
    parameters {
        string(name: 'PERSON', defaultValue: 'Mr Jenkins', description: 'Who should I say hello to?')
    }
    stages {
        stage('Example') {
            steps {
                echo &quot;Hello ${params.PERSON}&quot;
            }
        }
    }
}
</code></pre>
<h4 id="triggers">triggers</h4>
<p>triggers指令定义了Pipeline自动化触发的方式。对于与源代码集成的Pipeline，如GitHub或BitBucket，triggers可能不需要基于webhook的集成也已经存在。目前只有两个可用的触发器：cron和pollSCM。</p>
<figure data-type="image" tabindex="8"><a href="https://testerhome.com/uploads/photo/2017/763dc697-6402-47a2-b90c-77453ad89b88.png!large"><img src="https://testerhome.com/uploads/photo/2017/763dc697-6402-47a2-b90c-77453ad89b88.png!large" alt="img"></a></figure>
<p><strong>Example</strong></p>
<pre><code>triggers
pipeline {
    agent any
    triggers {
        cron('H 4/* 0 0 1-5')
    }
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
</code></pre>
<h4 id="stage">stage</h4>
<p>stage指令在stages部分中，应包含stop部分，可选agent部分或其他特定于stage的指令。实际上，Pipeline完成的所有实际工作都将包含在一个或多个stage指令中。</p>
<figure data-type="image" tabindex="9"><a href="https://testerhome.com/uploads/photo/2017/3bdce47e-87af-4264-8c9d-68f27cdf816c.png!large"><img src="https://testerhome.com/uploads/photo/2017/3bdce47e-87af-4264-8c9d-68f27cdf816c.png!large" alt="img"></a></figure>
<p><strong>Example</strong></p>
<pre><code>stage
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
</code></pre>
<h4 id="tools">tools</h4>
<p>通过tools可自动安装工具，并放置环境变量到PATH。如果agent none，这将被忽略。</p>
<figure data-type="image" tabindex="10"><a href="https://testerhome.com/uploads/photo/2017/027fa60d-c999-477c-a333-172f92ec5f91.png!large"><img src="https://testerhome.com/uploads/photo/2017/027fa60d-c999-477c-a333-172f92ec5f91.png!large" alt="img"></a></figure>
<p><strong>Supported Tools</strong><br>
maven<br>
jdk<br>
gradle</p>
<p><strong>Example</strong></p>
<pre><code>tools
pipeline {
    agent any
    tools {
        //工具名称必须在Jenkins 管理Jenkins → 全局工具配置中预配置。
        maven 'apache-maven-3.0.1'
    }
    stages {
        stage('Example') {
            steps {
                sh 'mvn --version'
            }
        }
    }
}
</code></pre>
<h4 id="when">when</h4>
<p>when指令允许Pipeline根据给定的条件确定是否执行该阶段。该when指令必须至少包含一个条件。如果when指令包含多个条件，则所有子条件必须为stage执行返回true。这与子条件嵌套在一个allOf条件中相同（见下面的例子）。<br>
更复杂的条件结构可使用嵌套条件建：not，allOf或anyOf。嵌套条件可以嵌套到任意深度。</p>
<figure data-type="image" tabindex="11"><a href="https://testerhome.com/uploads/photo/2017/e9d5d0eb-9855-4a72-a4a6-56c1fde975de.png!large"><img src="https://testerhome.com/uploads/photo/2017/e9d5d0eb-9855-4a72-a4a6-56c1fde975de.png!large" alt="img"></a></figure>
<p><strong>内置条件</strong><br>
branch<br>
当正在构建的分支与给出的分支模式匹配时执行，例如：when { branch 'master' }。请注意，这仅适用于多分支Pipeline。<br>
environment<br>
当指定的环境变量设置为给定值时执行，例如： when { environment name: 'DEPLOY_TO', value: 'production' }<br>
expression<br>
当指定的Groovy表达式求值为true时执行，例如： when { expression { return params.DEBUG_BUILD } }<br>
not<br>
当嵌套条件为false时执行。必须包含一个条件。例如：when { not { branch 'master' } }<br>
allOf<br>
当所有嵌套条件都为真时执行。必须至少包含一个条件。例如：when { allOf { branch 'master'; environment name: 'DEPLOY_TO', value: 'production' } }<br>
anyOf<br>
当至少一个嵌套条件为真时执行。必须至少包含一个条件。例如：when { anyOf { branch 'master'; branch 'staging' } }</p>
<p><strong>Example</strong></p>
<pre><code>when
pipeline {
    agent any
    stages {
        stage('Example Build') {
            steps {
                echo 'Hello World'
            }
        }
        stage('Example Deploy') {
            when {
                allOf {
                    branch 'production'
                    environment name: 'DEPLOY_TO', value: 'production'
                }
            }
            steps {
                echo 'Deploying'
            }
        }
    }
}
</code></pre>
<h3 id="3parallel并行">3.Parallel(并行)</h3>
<p>2017.9.25新增parallel stage支持。<br>
Declarative Pipeline近期新增了对并行嵌套stage的支持，对耗时长，相互不存在依赖的stage可以使用此方式提升运行效率。除了parallel stage，单个parallel里的多个step也可以使用并行的方式运行。</p>
<p><strong>Example</strong></p>
<pre><code>Jenkinsfile (Declarative Pipeline)
pipeline {
    agent any
    stages {
        stage('Non-Parallel Stage') {
            steps {
                echo 'This stage will be executed first.'
            }
        }
        stage('Parallel Stage') {
            when {
                branch 'master'
            }
            parallel {
                stage('Branch A') {
                    agent {
                        label &quot;for-branch-a&quot;
                    }
                    steps {
                        echo &quot;On Branch A&quot;
                    }
                }
                stage('Branch B') {
                    agent {
                        label &quot;for-branch-b&quot;
                    }
                    steps {
                        echo &quot;On Branch B&quot;
                    }
                }
            }
        }
    }
}
</code></pre>
<h3 id="4steps步骤">4.Steps（步骤）</h3>
<p>Declarative Pipeline可以使用 Pipeline Steps reference中的所有可用步骤 ，并附加以下仅在Declarative Pipeline中支持的步骤。</p>
<h4 id="script">script</h4>
<p>script步骤需要一个script Pipeline，并在Declarative Pipeline中执行。对于大多数用例，script在Declarative Pipeline中的步骤不是必须的，但它可以提供一个有用的加强。</p>
<p><strong>Example</strong></p>
<pre><code>script
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'

                script {
                    def browsers = ['chrome', 'firefox']
                    for (int i = 0; i &lt; browsers.size(); ++i) {
                        echo &quot;Testing the ${browsers[i]} browser&quot;
                    }
                }
            }
        }
    }
}
</code></pre>
<h2 id="四-scripted-pipeline">四、Scripted Pipeline</h2>
<p>Groovy脚本不一定适合所有使用者，因此jenkins创建了Declarative pipeline，为编写Jenkins管道提供了一种更简单、更有主见的语法。但是不可否认，由于脚本化的pipeline是基于groovy的一种DSL语言，所以与Declarative pipeline相比为jenkins用户提供了更巨大的灵活性和可扩展性。</p>
<h3 id="1流程控制">1.流程控制</h3>
<p>pipeline脚本同其它脚本语言一样，从上至下顺序执行，它的流程控制取决于Groovy表达式，如if/else条件语句，举例如下：</p>
<pre><code>Jenkinsfile (Scripted Pipeline)
node {
    stage('Example') {
        if (env.BRANCH_NAME == 'master') {
            echo 'I only execute on the master branch'
        } else {
            echo 'I execute elsewhere'
        }
    }
}
</code></pre>
<p>pipeline脚本流程控制的另一种方式是Groovy的异常处理机制。当任何一个步骤因各种原因而出现异常时，都必须在Groovy中使用try/catch/finally语句块进行处理，举例如下：</p>
<pre><code>Jenkinsfile (Scripted Pipeline)
node {
    stage('Example') {
        try {
            sh 'exit 1'
        }
        catch (exc) {
            echo 'Something failed, I should sound the klaxons!'
            throw
        }
    }
}
</code></pre>
<h3 id="2steps">2.Steps</h3>
<p>正如文档开始所言，pipeline最核心和基本的部分就是“step”，从根本上来说，steps作为Declarative pipeline和Scripted pipeline语法的最基本的语句构建块来告诉jenkins应该执行什么操作。<br>
Scripted pipeline没有专门将steps作为它的语法的一部分来介绍，但是在Pipeline Steps reference这篇文档中对pipeline及其插件涉及的steps做了很详细的介绍。如有需要可参考jenkins官网对该部分的介绍Pipeline Steps reference</p>
<h3 id="3differences-from-plain-groovy">3.Differences from plain Groovy</h3>
<p>由于pipeline的一些个性化需求，比如在重新启动jenkins后要求pipeline脚本仍然可以运行，那么pipeline脚本必须将相关数据做序列化，然而这一点 Groovy并不能完美的支持，例如collection.each { item -&gt; /* perform operation */ }</p>
<h3 id="4declarative-pipeline和scripted-pipeline的比较">4.Declarative pipeline和Scripted pipeline的比较</h3>
<p>共同点：<br>
两者都是pipeline代码的持久实现，都能够使用pipeline内置的插件或者插件提供的steps，两者都可以利用共享库扩展。<br>
区别：<br>
两者不同之处在于语法和灵活性。Declarative pipeline对用户来说，语法更严格，有固定的组织结构，更容易生成代码段，使其成为用户更理想的选择。但是Scripted pipeline更加灵活，因为Groovy本身只能对结构和语法进行限制，对于更复杂的pipeline来说，用户可以根据自己的业务进行灵活的实现和扩展。</p>
<p><a href="https://testerhome.com/cay">原文链接:TesterHome@cay</a></p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="http://wangqunsong.github.io/post/zai-ming-ling-xing-xia-chu-li-yaml">
                                <h3 class="post-title">
                                    在命令行下处理 YAML
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">一、写在前面</a></li>
<li><a href="#%E4%BA%8C-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B">二、语法简介</a></li>
<li><a href="#%E4%B8%89-declarative-pipeline">三、Declarative Pipeline</a>
<ul>
<li><a href="#1sections%E7%AB%A0%E8%8A%82">1.Sections（章节）</a>
<ul>
<li><a href="#agent">agent</a></li>
<li><a href="#post">post</a></li>
<li><a href="#stages">stages</a></li>
<li><a href="#steps">steps</a></li>
</ul>
</li>
<li><a href="#2directives-%E6%8C%87%E4%BB%A4">2.Directives （指令）</a>
<ul>
<li><a href="#environment">environment</a></li>
<li><a href="#options">options</a></li>
<li><a href="#parameters">parameters</a></li>
<li><a href="#triggers">triggers</a></li>
<li><a href="#stage">stage</a></li>
<li><a href="#tools">tools</a></li>
<li><a href="#when">when</a></li>
</ul>
</li>
<li><a href="#3parallel%E5%B9%B6%E8%A1%8C">3.Parallel(并行)</a></li>
<li><a href="#4steps%E6%AD%A5%E9%AA%A4">4.Steps（步骤）</a>
<ul>
<li><a href="#script">script</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-scripted-pipeline">四、Scripted Pipeline</a>
<ul>
<li><a href="#1%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">1.流程控制</a></li>
<li><a href="#2steps">2.Steps</a></li>
<li><a href="#3differences-from-plain-groovy">3.Differences from plain Groovy</a></li>
<li><a href="#4declarative-pipeline%E5%92%8Cscripted-pipeline%E7%9A%84%E6%AF%94%E8%BE%83">4.Declarative pipeline和Scripted pipeline的比较</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="http://www.zootopia.top/" target="_blank">zootopia</a> | 
  <a class="rss" href="http://wangqunsong.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>