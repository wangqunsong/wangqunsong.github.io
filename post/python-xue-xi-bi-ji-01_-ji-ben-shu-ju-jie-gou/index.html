<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Python学习笔记01_基本数据结构 | zootopia
</title>
<link rel="shortcut icon" href="http://wangqunsong.github.io/favicon.ico?v=1569414907689">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://wangqunsong.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="http://wangqunsong.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="http://wangqunsong.github.io">
                <img class="avatar" src="http://wangqunsong.github.io/images/avatar.png?v=1569414907689" alt="">
            </a>
            <div class="site-title">
                <h1>
                    zootopia
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="http://wangqunsong.github.io" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="http://wangqunsong.github.io/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="http://wangqunsong.github.io/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            Python学习笔记01_基本数据结构
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2016-11-07</time>
                            
                                <a href="http://wangqunsong.github.io/tag/1sgoPsPP5" class="post-tag i-tag
                            i-tag-other_2">
                            #Python
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>Python学习笔记01_基本数据结构</strong></p>
<!-- more -->
<h4 id="1字符编码">1.字符编码</h4>
<ul>
<li>计算机通用字符编码工作方式：<strong>计算机在内存中，统一使用<code>Unicode</code>编码，需要保存到硬盘或使用网络传输时，就转换为<code>UTF-8</code>编码；</strong></li>
<li><code>Python3</code>中的字符串<code>str</code>在内存中使用<code>Unicode</code>编码，如果要在网络上传输或者保存到磁盘，就需要把<code>str</code>转换为以字节为单位的<code>bytes</code>；</li>
<li><code>str</code>转换为<code>bytes</code>用<code>encode()</code>，反之则用<code>decode()</code>方法。</li>
</ul>
<!-- more -->
<h4 id="2list和tuple">2.list和tuple</h4>
<p><code>list</code>和<code>tuple</code>是<code>Python</code>内置的有序集合。<code>list</code>可变，<code>tuple</code>（指向）不可变，常用方法/函数有：</p>
<pre><code class="language-py">【函数】：
cmp(list1, list2)：比较两个列表的元素
len(list)：列表元素个数
max(list)：返回列表元素最大值
min(list)：返回列表元素最小值
list(seq)：将元组转换为列表
Python包含以下方法:
【方法】：
list.append(obj)：在列表末尾添加新的对象
list.count(obj)：统计某个元素在列表中出现的次数
list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
list.index(obj)：从列表中找出某个值第一个匹配项的索引位置
list.insert(index, obj)：将对象插入列表
list.pop([index=-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
list.remove(obj)：移除列表中某个值的第一个匹配项
list.reverse()：反向列表中元素
list.sort(cmp=None, key=None, reverse=False)：对原列表进行排序
</code></pre>
<h4 id="3dict和set">3.dict和set</h4>
<p><code>dict</code>和<code>set</code>是<code>Python</code>内置的无序集合。<code>dict</code>使用键-值（<code>key-value</code>）存储，<code>dict</code>的<code>key</code>必须是<strong>不可变对象</strong>，因为<code>dict</code>使用哈希算法通过<code>key</code>值计算<code>value</code>的存储位置。<code>set</code>中没有重复的<code>key</code>。常用方法/函数有：</p>
<pre><code class="language-python">【函数】：
cmp(dict1, dict2)：比较两个字典的元素
len(dict)：计算字典元素个数，即键的总数。
str(dict)：输出字典可打印的字符串表示。
type(variable)：返回输入的变量类型，如果变量是字典就返回字典类型。
【方法】：
dict.clear()：删除字典内所有元素
dict.copy()：返回一个字典的浅复制
dict.fromkeys(seq[, val])：创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
dict.get(key, default=None)：返回指定键的值，如果值不在字典中返回default值
dict.has_key(key)：如果键在字典dict里返回true，否则返回false
dict.items()：以列表返回可遍历的(键, 值) 元组数组
dict.keys()：以列表返回一个字典所有的键
dict.setdefault(key, default=None)：和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
dict.update(dict2)：把字典dict2的键/值对更新到dict里
dict.values()：以列表返回字典中的所有值
pop(key[,default])：删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。否则，返回default值。
popitem()：随机返回并删除字典中的一对键和值。
</code></pre>
<h4 id="4切片">4.切片</h4>
<p>取一个list或tuple的部分元素，Python提供了切片（Slice）操作符。切片<code>L[a:b]</code>结果长度为<code>b-a</code>，<code>左开右闭</code>。</p>
<pre><code>&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
&gt;&gt;&gt; L[0:3]
['Michael', 'Sarah', 'Tracy']
</code></pre>
<p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素；</p>
<p>类似的，既然Python支持<code>L[-1]</code>取倒数第一个元素，那么它同样支持倒数切片：</p>
<pre><code>&gt;&gt;&gt; L[-2:]
['Bob', 'Jack']
&gt;&gt;&gt; L[-2:-1]
['Bob']
</code></pre>
<p>字符串<code>'xxx'</code>也可以用切片操作，操作结果仍是字符串；tuple也可以用切片操作，只是操作的结果仍是tuple。</p>
<pre><code>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
&gt;&gt;&gt; 'ABCDEFG'[:3]
'ABC'
&gt;&gt;&gt; 'ABCDEFG'[::2]
'ACEG'
</code></pre>
<h4 id="5迭代">5.迭代</h4>
<p>给定一个list或tuple，可以通过<code>for</code>循环来遍历这个list或tuple，这种遍历称为迭代（Iteration）；任何可迭代对象都可以作用于<code>for</code>循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用<code>for</code>循环。</p>
<p>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</p>
<pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False
</code></pre>
<h4 id="6迭代器">6.迭代器</h4>
<h5 id="a可迭代对象">【a】可迭代对象</h5>
<p>Python中任意的对象，只要它定义了可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可支持下标索引的<code>__getitem__</code>方法，那么它就是一个可迭代对象。简单说，可迭代对象就是能提供迭代器的任意对象；或者说，可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>，可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象。</p>
<h5 id="b迭代器">【b】迭代器</h5>
<p>任意对象，只要定义了<code>next</code>(Python2) 或者<code>__next__</code>方法，它就是一个迭代器（<code>Iterator</code>）。或者说，可以被<code>next()</code>函数调用并<strong>不断返回下一个值</strong>的对象称为迭代器：<code>Iterator</code>。可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象。</p>
<h5 id="c可迭代对象-迭代器">【c】可迭代对象 → 迭代器</h5>
<p>把可迭代对象转换为迭代器需要用到<code>iter()</code>函数：</p>
<pre><code>my_string = &quot;Wang&quot;
my_iter = iter(my_string)
next(my_iter)
# Output: 'W'
</code></pre>
<p>最后，<code>list</code>为什么是可迭代对象，而不是迭代器？</p>
<blockquote>
<p>Python的<strong>迭代器</strong>表示的是一个数据流，<strong>迭代器</strong>可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<strong>迭代器</strong>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p><strong>迭代器</strong>甚至可以表示一个无限大的数据流，例如全体自然数。而使用<code>list</code>是永远不可能存储全体自然数的。</p>
</blockquote>
<h4 id="7列表生成式">7.列表生成式</h4>
<p>列表生成式即List Comprehensions，是Python内置的用来创建list的生成式。</p>
<pre><code>&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<p>书写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来。更多的：</p>
<pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']
&gt;&gt;&gt; [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
</code></pre>
<h4 id="8生成器">8.生成器</h4>
<p>生成器也是一种迭代器，但是只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。在Python中，这种一边循环一边计算的机制，称为生成器：<code>generator</code>。<code>generator</code>是非常强大的工具，在Python中，可以简单地把列表生成式改成<code>generator</code>，也可以通过函数实现复杂逻辑的<code>generator</code>。大多数时候生成器是以函数来实现的。然而，它们并不返回一个值，而是<code>yield</code>(暂且译作“生出”)一个值。</p>
<p>要想使用<code>generator</code>，要么用一个<code>for</code>循环，要么将它们传递给任意可以进行迭代的函数和结构。</p>
<h5 id="创建生成器_方式1">创建生成器_方式1</h5>
<p>第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p>
<pre><code>&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
</code></pre>
<p>创建<code>L</code>和<code>g</code>的区别仅在于最外层的<code>[]</code>和<code>()</code>，<code>L</code>是一个list，而<code>g</code>是一个<code>generator</code>。<code>generator</code>保存的是算法，每次调用<code>next(g)</code>，就计算出<code>g</code>的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p>
<p>不过，更多的是利用<code>for</code>循环遍历：</p>
<pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; for n in g:
...     print(n)
... 
0
1
4
9
16
25
36
49
64
81
</code></pre>
<h5 id="创建生成器_方式2">创建生成器_方式2</h5>
<p>使用函数来实现生成器，它并不返回一个值，而是<code>yield</code>(暂且译作“生出”)一个值。如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p>
<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
 
&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f
&lt;generator object fib at 0x104feaaa0&gt;
</code></pre>
<p>这里要特别指出的是，<code>generator</code>和函数的执行流程不一样。函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成<code>generator</code>的函数（即生成器），在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p>
<p>举个例子，定义一个generator，依次返回数字1，2，3：</p>
<pre><code>def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(2)
    print('step 3')
    yield(3)
</code></pre>
<p>调用该generator时，首先要生成一个generator对象，然后用<code>next()</code>函数不断获得下一个返回值：</p>
<pre><code>&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
2
&gt;&gt;&gt; next(o)
step 3
3
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>可以看到，<code>odd</code>不是普通函数，而是generator，在执行过程中，遇到<code>yield</code>就中断，下次又继续执行。执行3次<code>yield</code>后，已经没有<code>yield</code>可以执行了，所以，第4次调用<code>next(o)</code>就报错。</p>
<p>上面提到过，把函数改成generator后，我们基本上不会用<code>next()</code>来获取下一个返回值，而是直接使用<code>for</code>循环来迭代：</p>
<pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'

&gt;&gt;&gt; for n in fib(6):
...     print(n)
...
1
1
2
3
5
8
</code></pre>
<p>但是用<code>for</code>循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p>
<pre><code>&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
</code></pre>
<p>参考链接1：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">穆雪峰的Python3教程</a></p>
<p>参考链接2：<a href="https://eastlakeside.gitbooks.io/interpy-zh/content/">Intermediate Python</a></p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="http://wangqunsong.github.io/post/chu-shi-markdown">
                                <h3 class="post-title">
                                    初识MarkDown
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#1%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">1.字符编码</a></li>
<li><a href="#2list%E5%92%8Ctuple">2.list和tuple</a></li>
<li><a href="#3dict%E5%92%8Cset">3.dict和set</a></li>
<li><a href="#4%E5%88%87%E7%89%87">4.切片</a></li>
<li><a href="#5%E8%BF%AD%E4%BB%A3">5.迭代</a></li>
<li><a href="#6%E8%BF%AD%E4%BB%A3%E5%99%A8">6.迭代器</a>
<ul>
<li><a href="#a%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1">【a】可迭代对象</a></li>
<li><a href="#b%E8%BF%AD%E4%BB%A3%E5%99%A8">【b】迭代器</a></li>
<li><a href="#c%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8">【c】可迭代对象 → 迭代器</a></li>
</ul>
</li>
<li><a href="#7%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F">7.列表生成式</a></li>
<li><a href="#8%E7%94%9F%E6%88%90%E5%99%A8">8.生成器</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%94%9F%E6%88%90%E5%99%A8_%E6%96%B9%E5%BC%8F1">创建生成器_方式1</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%94%9F%E6%88%90%E5%99%A8_%E6%96%B9%E5%BC%8F2">创建生成器_方式2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="http://www.zootopia.top/" target="_blank">zootopia</a> | 
  <a class="rss" href="http://wangqunsong.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>