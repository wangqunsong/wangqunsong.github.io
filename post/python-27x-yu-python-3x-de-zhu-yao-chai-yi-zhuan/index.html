<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Python 2.7.x 与 Python 3.x 的主要差异「转] | zootopia
</title>
<link rel="shortcut icon" href="http://wangqunsong.github.io/favicon.ico?v=1569414907689">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://wangqunsong.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="http://wangqunsong.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="http://wangqunsong.github.io">
                <img class="avatar" src="http://wangqunsong.github.io/images/avatar.png?v=1569414907689" alt="">
            </a>
            <div class="site-title">
                <h1>
                    zootopia
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="http://wangqunsong.github.io" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="http://wangqunsong.github.io/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="http://wangqunsong.github.io/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            Python 2.7.x 与 Python 3.x 的主要差异「转]
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2017-02-16</time>
                            
                                <a href="http://wangqunsong.github.io/tag/1sgoPsPP5" class="post-tag i-tag
                            i-tag-banana">
                            #Python
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>Python 2.7.x 与 Python 3.x 的主要差异「转]</strong></p>
<!-- more -->
<blockquote>
<p><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/">原文链接-中文</a></p>
<p><a href="https://nbviewer.jupyter.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1">原文链接-英文</a></p>
</blockquote>
<h2 id="__future__模块"><strong>__future__模块</strong></h2>
<p>Python 3.x 介绍的 一些Python 2 不兼容的关键字和特性可以通过在 Python 2 的内置 <code>__future__</code> 模块导入。如果你计划让你的代码支持 Python 3.x，建议你使用 <code>__future__</code> 模块导入。例如，如果我想要 在Python 2 中表现 Python 3.x 中的整除，我们可以通过如下导入</p>
<pre><code>from __future__ import division
</code></pre>
<p>更多的 <code>__future__</code> 模块可被导入的特性被列在下表中：</p>
<table>
<thead>
<tr>
<th><strong>feature</strong></th>
<th><strong>optional in</strong></th>
<th><strong>mandatory in</strong></th>
<th><strong>effect</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>nested_scopes</td>
<td>2.1.0b1</td>
<td>2.2</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0227/">PEP 227</a>: Statically Nested Scopes</td>
</tr>
<tr>
<td>generators</td>
<td>2.2.0a1</td>
<td>2.3</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0255/">PEP 255</a>: Simple Generators</td>
</tr>
<tr>
<td>division</td>
<td>2.2.0a2</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0238/">PEP 238</a>: Changing the Division Operator</td>
</tr>
<tr>
<td>absolute_import</td>
<td>2.5.0a1</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0328/">PEP 328</a>: Imports: Multi-Line and Absolute/Relative</td>
</tr>
<tr>
<td>with_statement</td>
<td>2.5.0a1</td>
<td>2.6</td>
<td><a href="http://www.python.org/dev/peps/pep-0343">PEP 343</a>: The “with” Statement</td>
</tr>
<tr>
<td>print_function</td>
<td>2.5.0a2</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-3105/">PEP 3105</a>: Make print a function</td>
</tr>
<tr>
<td>unicode_literals</td>
<td>2.5.0a2</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-3112/">PEP 3112</a>: Bytes literals in Python 3000</td>
</tr>
</tbody>
</table>
<p>(Source: <a href="https://docs.python.org/2/library/future.html">https://docs.python.org/2/library/future.html</a>)</p>
<pre><code>from platform import python_version
</code></pre>
<h2 id="print函数"><strong>print函数</strong></h2>
<p>很琐碎，而 <code>print</code> 语法的变化可能是最广为人知的了，但是仍值得一提的是： Python 2 的 print 声明已经被 <code>print()</code> 函数取代了，这意味着我们必须包装我们想打印在小括号中的对象。<br>
Python 2 不具有额外的小括号问题。但对比一下，如果我们按照 Python 2 的方式不使用小括号调用 <code>print</code> 函数，Python 3 将抛出一个语法异常（<code>SyntaxError</code>）。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print 'Hello, World!'
print('Hello, World!')
print &quot;text&quot;, ; print 'print more text on the same line'
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6<br>
Hello, World!<br>
Hello, World!<br>
text print more text on the same line</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('Hello, World!')
print(&quot;some text,&quot;, end=&quot;&quot;) 
print(' print more text on the same line')
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1<br>
Hello, World!<br>
some text, print more text on the same line</p>
<pre><code>print 'Hello, World!'
</code></pre>
<p><em>run result:</em><br>
File ““, line 1<br>
　　print ‘Hello, World!’<br>
　　　　　　　　　　^<br>
SyntaxError: invalid syntax</p>
<p><strong>Note:</strong><br>
　　以上通过 Python 2 使用 <code>Printing &quot;Hello, World&quot;</code> 是非常正常的，尽管如此，如果你有多个对象在小括号中，我们将创建一个元组，因为 <code>print</code> 在 Python 2 中是一个声明，而不是一个函数调用。</p>
<pre><code>print 'Python', python_version()
print('a', 'b')
print 'a', 'b'
</code></pre>
<p><em>run result:</em><br>
Python 2.7.7<br>
(‘a’, ‘b’)<br>
a b</p>
<h2 id="整除"><strong>整除</strong></h2>
<p>如果你正在移植代码，这个变化是特别危险的。或者你在 Python 2 上执行 Python 3 的代码。因为这个整除的变化表现在它会被忽视（即它不会抛出语法异常）。<br>
　　因此，我还是倾向于使用一个 <code>float(3)/2</code> 或 <code>3/2.0</code> 代替在我的 Python 3 脚本保存在 Python 2 中的 <code>3/2</code> 的一些麻烦（并且反而过来也一样，我建议在你的 Python 2 脚本中使用 <code>from __future__ import division</code>）<br>
<strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print '3 / 2 =', 3 / 2
print '3 // 2 =', 3 // 2
print '3 / 2.0 =', 3 / 2.0
print '3 // 2.0 =', 3 // 2.0
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6<br>
3 / 2 = 1<br>
3 // 2 = 1<br>
3 / 2.0 = 1.5<br>
3 // 2.0 = 1.0</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('3 / 2 =', 3 / 2)
print('3 // 2 =', 3 // 2)
print('3 / 2.0 =', 3 / 2.0)
print('3 // 2.0 =', 3 // 2.0)
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1<br>
3 / 2 = 1.5<br>
3 // 2 = 1<br>
3 / 2.0 = 1.5<br>
3 // 2.0 = 1.0</p>
<h2 id="unicode"><strong>Unicode</strong></h2>
<p>Python 2 有 ASCII str() 类型，<code>unicode()</code> 是单独的，不是 <code>byte</code> 类型。<br>
　　现在， 在 Python 3，我们最终有了 <code>Unicode (utf-8)</code> 字符串，以及一个字节类：<code>byte</code> 和 <code>bytearrays</code>。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6</p>
<pre><code>print type(unicode('this is like a python3 str type'))
</code></pre>
<p><em>run result:</em><br>
&lt; type ‘unicode’ &gt;</p>
<pre><code>print type(b'byte type does not exist')
</code></pre>
<p><em>run result:</em><br>
&lt; type ‘str’ &gt;</p>
<pre><code>print 'they are really' + b' the same'
</code></pre>
<p><em>run result:</em><br>
they are really the same</p>
<pre><code>print type(bytearray(b'bytearray oddly does exist though'))
</code></pre>
<p><em>run result:</em><br>
&lt; type ‘bytearray’ &gt;</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('strings are now utf-8 \u03BCnico\u0394é!')
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1<br>
strings are now utf-8 μnicoΔé!</p>
<pre><code>print('Python', python_version(), end=&quot;&quot;)
print(' has', type(b' bytes for storing data'))
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1 has &lt; class ‘bytes’ &gt;</p>
<pre><code>print('and Python', python_version(), end=&quot;&quot;)
print(' also has', type(bytearray(b'bytearrays')))
</code></pre>
<p><em>run result:</em><br>
and Python 3.4.1 also has &lt; class ‘bytearray’&gt;</p>
<pre><code>'note that we cannot add a string' + b'bytes for data'
</code></pre>
<p><em>run result:</em><br>
-—————————————————————————————————————<br>
TypeError Traceback (most recent call last)<br>
&lt; ipython-input-13-d3e8942ccf81&gt; in &lt; module&gt;()<br>
——&gt; 1 ‘note that we cannot add a string’ + b’bytes for data’</p>
<p>TypeError: Can’t convert ‘bytes’ object to str implicitly</p>
<h2 id="xrange模块"><strong>xrange模块</strong></h2>
<p>在 Python 2 中 <code>xrange()</code> 创建迭代对象的用法是非常流行的。比如： <code>for</code> 循环或者是列表/集合/字典推导式。<br>
　　这个表现十分像生成器（比如。“惰性求值”）。但是这个 <code>xrange-iterable</code> 是无穷的，意味着你可以无限遍历。<br>
　　由于它的惰性求值，如果你不得仅仅不遍历它一次，<code>xrange()</code> 函数 比 <code>range()</code> 更快（比如 <code>for</code> 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。<br>
　　在 Python 3 中，<code>range()</code> 是像 <code>xrange()</code> 那样实现以至于一个专门的 <code>xrange()</code> 函数都不再存在（在 Python 3 中 <code>xrange()</code> 会抛出命名异常）。</p>
<pre><code>import timeit
n = 10000
def test_range(n):
    return for i in range(n):
        pass
def test_xrange(n):
    for i in xrange(n):
        pass
</code></pre>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print '\ntiming range()'
%timeit test_range(n)
print '\n\ntiming xrange()'
%timeit test_xrange(n)
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6</p>
<p>timing range()<br>
1000 loops, best of 3: 433 µs per loop</p>
<p>timing xrange()<br>
1000 loops, best of 3: 350 µs per loop</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('\ntiming range()')
%timeit test_range(n)
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1</p>
<p>timing range()<br>
1000 loops, best of 3: 520 µs per loop</p>
<pre><code>print(xrange(10))
</code></pre>
<p><em>run result:</em><br>
-—————————————————————————————————————<br>
NameError Traceback (most recent call last)</p>
<p>in ()<br>
——&gt; 1 print(xrange(10))</p>
<p>NameError: name ‘xrange’ is not defined</p>
<h2 id="python3中的range对象的__contains__方法"><strong>Python3中的range对象的__contains__方法</strong></h2>
<p>另外一件值得一提的事情就是在 Python 3 中 <code>range</code> 有一个新的 <code>__contains__</code> 方法（感谢 Yuchen Ying 指出了这个），<code>__contains__</code> 方法可以加速 “查找” 在 Python 3.x 中显著的整数和布尔类型。</p>
<pre><code>x = 10000000
def val_in_range(x, val):
    return val in range(x)
def val_in_xrange(x, val):
    return val in xrange(x)
print('Python', python_version())
assert(val_in_range(x, x/2) == True)
assert(val_in_range(x, x//2) == True)
%timeit val_in_range(x, x/2)
%timeit val_in_range(x, x//2)
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1<br>
1 loops, best of 3: 742 ms per loop<br>
1000000 loops, best of 3: 1.19 µs per loop<br>
　　基于以上的 timeit 的结果，当它使一个整数类型，而不是浮点类型的时候，你可以看到执行查找的速度是 60000 倍快。尽管如此，因为 Python 2.x 的 <code>range</code> 或者是 <code>xrange</code> 没有一个 <code>__contains__</code> 方法，这个整数类型或者是浮点类型的查询速度不会相差太大。</p>
<pre><code>print 'Python', python_version()
assert(val_in_xrange(x, x/2.0) == True)
assert(val_in_xrange(x, x/2) == True)
assert(val_in_range(x, x/2) == True)
assert(val_in_range(x, x//2) == True)
%timeit val_in_xrange(x, x/2.0)
%timeit val_in_xrange(x, x/2)
%timeit val_in_range(x, x/2.0)
%timeit val_in_range(x, x/2)
</code></pre>
<p><em>run result:</em><br>
Python 2.7.7<br>
1 loops, best of 3: 285 ms per loop<br>
1 loops, best of 3: 179 ms per loop<br>
1 loops, best of 3: 658 ms per loop<br>
1 loops, best of 3: 556 ms per loop<br>
　　下面说下 <code>__contain__</code>方法并没有加入到 Python 2.x 中的证据：</p>
<pre><code>print('Python', python_version())
range.__contains__
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1</p>
<p>&lt; slot wrapper ‘<strong>contains</strong>‘ of ‘range’ objects &gt;</p>
<pre><code>print 'Python', python_version()
range.__contains__
</code></pre>
<p><em>run result:</em><br>
Python 2.7.7</p>
<p>-—————————————————————————————————————<br>
AttributeError Traceback (most recent call last)<br>
&lt; ipython-input-7-05327350dafb&gt; in &lt; module&gt;()<br>
1 print ‘Python’, python*version()——&gt; 2 range.<code>_contains*</code></p>
<p>AttributeError: ‘builtin*functionor_method’ object has no attribute <code>’__contains*‘</code></p>
<pre><code>print 'Python', python_version()
xrange.__contains__
</code></pre>
<p><em>run result:</em><br>
Python 2.7.7</p>
<p>-—————————————————————————————————————<br>
AttributeError Traceback (most recent call last)<br>
&lt; ipython-input-8-7d1a71bfee8e&gt; in &lt; module&gt;()<br>
1 print ‘Python’, python*version()——&gt; 2 xrange.<code>_contains*</code></p>
<p>AttributeError: type object ‘xrange’ has no attribute <code>'__contains__'</code></p>
<p><strong>注意在 Python 2 和 Python 3 中速度的不同</strong><br>
　　有些人指出了 Python 3 的 <code>range()</code> 和 Python 2 的 <code>xrange()</code> 之间的速度不同。因为他们是用相同的方法实现的，因此期望相同的速度。尽管如此，这事实在于 Python 3 倾向于比 Python 2 运行的慢一点。</p>
<pre><code>def test_while():
    i = 0
    while i &lt; 20000:
        i += 1
    return
</code></pre>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
%timeit test_while()
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1<br>
100 loops, best of 3: 2.68 ms per loop</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
%timeit test_while()
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6<br>
1000 loops, best of 3: 1.72 ms per loop</p>
<h2 id="raising-exceptions"><strong>Raising exceptions</strong></h2>
<p>Python 2 接受新旧两种语法标记，在 Python 3 中如果我不用小括号把异常参数括起来就会阻塞（并且反过来引发一个语法异常）。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6</p>
<pre><code>raise IOError, &quot;file error&quot;
</code></pre>
<p><em>run result:</em></p>
<p>-—————————————————————————————————————<br>
IOError Traceback (most recent call last)<br>
&lt; ipython-input-8-25f049caebb0&gt; in &lt; module&gt;()<br>
——&gt; 1 raise IOError, “file error”</p>
<p>IOError: file error</p>
<pre><code>raise IOError(&quot;file error&quot;)
</code></pre>
<p><em>run result:</em><br>
-—————————————————————————————————————<br>
IOError Traceback (most recent call last)<br>
&lt; ipython-input-9-6f1c43f525b2&gt; in &lt; module&gt;()<br>
——&gt; 1 raise IOError(“file error”)</p>
<p>IOError: file error</p>
<p><strong>Python 3</strong></p>
<pre><code>print 'Python', python_version()
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1</p>
<pre><code>raise IOError, &quot;file error&quot;
</code></pre>
<p><em>run result:</em></p>
<p>File ““, line 1<br>
raise IOError, “file error”<br>
　　　　　　^<br>
SyntaxError: invalid syntax<br>
　　在 Python 3 中，可以这样抛出异常：</p>
<pre><code>print('Python', python_version())
raise IOError(&quot;file error&quot;)
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1</p>
<p>-—————————————————————————————————————<br>
OSError Traceback (most recent call last)<br>
&lt; ipython-input-11-c350544d15da&gt; in &lt; module&gt;()<br>
1 print(‘Python’, python_version())<br>
——&gt; 2 raise IOError(“file error”)</p>
<p>OSError: file error</p>
<h2 id="handling-exceptions"><strong>Handling exceptions</strong></h2>
<p>在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 <code>as</code> 作为关键词。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
try:
    let_us_cause_a_NameError
except NameError, err:
    print err, '--&gt; our error message'
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6<br>
name ‘let_us_cause_a_NameError’ is not defined —&gt; our error message</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
try:
    let_us_cause_a_NameError
except NameError as err:
    print(err, '--&gt; our error message')
</code></pre>
<p><em>run result:</em></p>
<p>Python 3.4.1<br>
name ‘let_us_cause_a_NameError’ is not defined —&gt; our error message</p>
<h2 id="next函数-and-next方法"><strong>next()函数 and .next()方法</strong></h2>
<p>因为 <code>next() (.next())</code> 是一个如此普通的使用函数（方法），这里有另外一个语法改变（或者是实现上改变了），值得一提的是：在 Python 2.7.5 中函数和方法你都可以使用，<code>next()</code> 函数在 Python 3 中一直保留着（调用 <code>.next()</code> 抛出属性异常）。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
my_generator = (letter for letter in 'abcdefg')
next(my_generator)
my_generator.next()
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6</p>
<p>‘b</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
my_generator = (letter for letter in 'abcdefg')
next(my_generator)
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1</p>
<p>‘a’</p>
<pre><code>my_generator.next()
</code></pre>
<p><em>run result:</em><br>
-—————————————————————————————————————<br>
AttributeError Traceback (most recent call last)<br>
&lt; ipython-input-14-125f388bb61b&gt; in &lt; module&gt;()<br>
——&gt; 1 my_generator.next()</p>
<p>AttributeError: ‘generator’ object has no attribute ‘next’</p>
<h2 id="for循环变量和全局命名空间泄漏"><strong>For循环变量和全局命名空间泄漏</strong></h2>
<p>好消息：在 Python 3.x 中 <code>for</code> 循环变量不会再导致命名空间泄漏。<br>
　　在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：<br>
　　“列表推导不再支持 <code>[... for var in item1, item2, ...]</code> 这样的语法。使用 <code>[... for var in (item1, item2, ...)]</code> 代替。也需要提醒的是列表推导有不同的语义： 他们关闭了在 <code>list()</code> 构造器中的生成器表达式的语法糖, 并且特别是循环控制变量不再泄漏进周围的作用范围域.”</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
i = 1
print 'before: i =', i
print 'comprehension: ', [i for i in range(5)]
print 'after: i =', i
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6<br>
before: i = 1<br>
comprehension: [0, 1, 2, 3, 4]<br>
after: i = 4</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
i = 1
print('before: i =', i)
print('comprehension:', [i for i in range(5)])
print('after: i =', i)
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1<br>
before: i = 1<br>
comprehension: [0, 1, 2, 3, 4]<br>
after: i = 1</p>
<h2 id="比较不可排序类型"><strong>比较不可排序类型</strong></h2>
<p>在 Python 3 中的另外一个变化就是当对不可排序类型做比较的时候，会抛出一个类型错误。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print &quot;[1, 2] &gt; 'foo' = &quot;, [1, 2] &gt; 'foo'
print &quot;(1, 2) &gt; 'foo' = &quot;, (1, 2) &gt; 'foo'
print &quot;[1, 2] &gt; (1, 2) = &quot;, [1, 2] &gt; (1, 2)
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6<br>
[1, 2] &gt; ‘foo’ = False<br>
(1, 2) &gt; ‘foo’ = True<br>
[1, 2] &gt; (1, 2) = False</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print(&quot;[1, 2] &gt; 'foo' = &quot;, [1, 2] &gt; 'foo')
print(&quot;(1, 2) &gt; 'foo' = &quot;, (1, 2) &gt; 'foo')
print(&quot;[1, 2] &gt; (1, 2) = &quot;, [1, 2] &gt; (1, 2))
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1</p>
<p>-—————————————————————————————————————<br>
TypeError Traceback (most recent call last)<br>
&lt; ipython-input-16-a9031729f4a0&gt; in &lt; module&gt;()<br>
1 print(‘Python’, python_version())<br>
——&gt; 2 print(“[1, 2] &gt; ‘foo’ = “, [1, 2] &gt; ‘foo’)<br>
3 print(“(1, 2) &gt; ‘foo’ = “, (1, 2) &gt; ‘foo’)<br>
4 print(“[1, 2] &gt; (1, 2) = “, [1, 2] &gt; (1, 2))</p>
<p>TypeError: unorderable types: list() &gt; str()</p>
<h2 id="通过input解析用户的输入"><strong>通过input()解析用户的输入</strong></h2>
<p>幸运的是，在 Python 3 中已经解决了把用户的输入存储为一个 <code>str</code> 对象的问题。为了避免在 Python 2 中的读取非字符串类型的危险行为，我们不得不使用 <code>raw_input()</code> 代替。</p>
<p><strong>Python 2</strong><br>
Python 2.7.6<br>
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin<br>
Type “help”, “copyright”, “credits” or “license” for more information.</p>
<pre><code>&gt;&gt;&gt; my_input = input('enter a number: ')

enter a number: 123

&gt;&gt;&gt; type(my_input)
&lt;type 'int'&gt;

&gt;&gt;&gt; my_input = raw_input('enter a number: ')

enter a number: 123

&gt;&gt;&gt; type(my_input)
&lt;type 'str'&gt;

</code></pre>
<p><strong>Python 3</strong><br>
Python 3.4.1<br>
[GCC 4.2.1 (Apple Inc. build 5577)] on darwin<br>
Type “help”, “copyright”, “credits” or “license” for more information.</p>
<pre><code>&gt;&gt;&gt; my_input = input('enter a number: ')

enter a number: 123

&gt;&gt;&gt; type(my_input)
&lt;class 'str'&gt;

</code></pre>
<h2 id="返回可迭代对象而不是列表"><strong>返回可迭代对象，而不是列表</strong></h2>
<p>如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 — 代替 Python 2 中的列表<br>
　　因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 —- 如需要遍历多次。它是不那么高效的。<br>
　　而对于那些情况下，我们真正需要的是列表对象，我们可以通过 <code>list()</code> 函数简单的把迭代对象转换成一个列表。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version() 
print range(3) 
print type(range(3))
</code></pre>
<p><em>run result:</em><br>
Python 2.7.6<br>
[0, 1, 2]<br>
&lt; type ‘list’&gt;</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print(range(3))
print(type(range(3)))
print(list(range(3)))
</code></pre>
<p><em>run result:</em><br>
Python 3.4.1<br>
range(0, 3)<br>
&lt; class ‘range’&gt;<br>
[0, 1, 2]<br>
　　在 Python 3 中一些经常使用到的不再返回列表的函数和方法：</p>
<ul>
<li><code>zip()</code></li>
<li><code>map()</code></li>
<li><code>filter()</code></li>
<li>dictionary’s <code>.keys()</code> method</li>
<li>dictionary’s <code>.values()</code> method</li>
<li>dictionary’s <code>.items()</code> method</li>
</ul>
<h2 id="更多的关于-python-2-和-python-3-的文章"><strong>更多的关于 Python 2 和 Python 3 的文章</strong></h2>
<p>下面是我建议后续的关于 Python 2 和 Python 3 的一些好文章。</p>
<p><strong>移植到 Python 3</strong></p>
<ul>
<li><a href="https://wiki.python.org/moin/Python2orPython3">Should I use Python 2 or Python 3 for my development activity?</a></li>
<li><a href="https://docs.python.org/3.0/whatsnew/3.0.html">What’s New In Python 3.0</a></li>
<li><a href="http://python3porting.com/differences.html">Porting to Python 3</a></li>
<li><a href="https://docs.python.org/3/howto/pyporting.html">Porting Python 2 Code to Python 3</a></li>
<li><a href="http://nothingbutsnark.svbtle.com/my-view-on-the-current-state-of-python-3">How keep Python 3 moving forward</a></li>
</ul>
<p><strong>Python 3 的拥护者和反对者</strong></p>
<ul>
<li><a href="http://asmeurer.github.io/python3-presentation/slides.html#1">10 awesome features of Python that you can’t use because you refuse to upgrade to Python 3</a></li>
<li><a href="http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/">Everything you did not want to know about Unicode in Python 3</a></li>
<li><a href="https://medium.com/@deliciousrobots/5d2ad703365dverything-about-unicode/">Python 3 is killing Python</a></li>
<li><a href="https://medium.com/@opinionbreaker/python-3-can-revive-python-2a7af4788b10">Python 3 can revive Python</a></li>
<li><a href="http://sealedabstract.com/rants/python-3-is-fine/">Python 3 is fine</a></li>
</ul>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="http://wangqunsong.github.io/post/python-xue-xi-bi-ji-09_socket-bian-cheng">
                                <h3 class="post-title">
                                    Python学习笔记09_Socket编程
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#__future__%E6%A8%A1%E5%9D%97"><strong>__future__模块</strong></a></li>
<li><a href="#print%E5%87%BD%E6%95%B0"><strong>print函数</strong></a></li>
<li><a href="#%E6%95%B4%E9%99%A4"><strong>整除</strong></a></li>
<li><a href="#unicode"><strong>Unicode</strong></a></li>
<li><a href="#xrange%E6%A8%A1%E5%9D%97"><strong>xrange模块</strong></a></li>
<li><a href="#python3%E4%B8%AD%E7%9A%84range%E5%AF%B9%E8%B1%A1%E7%9A%84__contains__%E6%96%B9%E6%B3%95"><strong>Python3中的range对象的__contains__方法</strong></a></li>
<li><a href="#raising-exceptions"><strong>Raising exceptions</strong></a></li>
<li><a href="#handling-exceptions"><strong>Handling exceptions</strong></a></li>
<li><a href="#next%E5%87%BD%E6%95%B0-and-next%E6%96%B9%E6%B3%95"><strong>next()函数 and .next()方法</strong></a></li>
<li><a href="#for%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F"><strong>For循环变量和全局命名空间泄漏</strong></a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E4%B8%8D%E5%8F%AF%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%9E%8B"><strong>比较不可排序类型</strong></a></li>
<li><a href="#%E9%80%9A%E8%BF%87input%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5"><strong>通过input()解析用户的输入</strong></a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%97%E8%A1%A8"><strong>返回可迭代对象，而不是列表</strong></a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E4%BA%8E-python-2-%E5%92%8C-python-3-%E7%9A%84%E6%96%87%E7%AB%A0"><strong>更多的关于 Python 2 和 Python 3 的文章</strong></a></li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="http://www.zootopia.top/" target="_blank">zootopia</a> | 
  <a class="rss" href="http://wangqunsong.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>