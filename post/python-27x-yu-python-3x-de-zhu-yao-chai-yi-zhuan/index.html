
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Python 2.7.x 与 Python 3.x 的主要差异「转] | 小小王的后花园</title>
<meta name="description" content="小小王的后花园">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="http://wangqunsong.top/favicon.ico?v=1556375647041">
<link rel="stylesheet" href="http://wangqunsong.top/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://wangqunsong.top">
        <img class="avatar" src="http://wangqunsong.top/images/avatar.png?v=1556375647041" alt="" width="32px" height="32px">
      </a>
      <a href="http://wangqunsong.top">
        <h1 class="site-title">小小王的后花园</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="http://wangqunsong.top" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="http://wangqunsong.top/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="http://wangqunsong.top/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="http://wangqunsong.top/post/guan-yu-wo/" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">Python 2.7.x 与 Python 3.x 的主要差异「转]</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2017-02-16</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="http://wangqunsong.top/tag/1sgoPsPP5">
                    Python
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>Python 2.7.x 与 Python 3.x 的主要差异「转]</strong></p>
<!-- more -->
<blockquote>
<p><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/">原文链接-中文</a></p>
<p><a href="https://nbviewer.jupyter.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1">原文链接-英文</a></p>
</blockquote>
<h2 id="__future__模块"><strong>__future__模块</strong></h2>
<p>Python 3.x 介绍的 一些Python 2 不兼容的关键字和特性可以通过在 Python 2 的内置 <code>__future__</code> 模块导入。如果你计划让你的代码支持 Python 3.x，建议你使用 <code>__future__</code> 模块导入。例如，如果我想要 在Python 2 中表现 Python 3.x 中的整除，我们可以通过如下导入</p>
<pre><code>from __future__ import division
</code></pre>
<p>更多的 <code>__future__</code> 模块可被导入的特性被列在下表中：</p>
<table>
<thead>
<tr>
<th><strong>feature</strong></th>
<th><strong>optional in</strong></th>
<th><strong>mandatory in</strong></th>
<th><strong>effect</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>nested_scopes</td>
<td>2.1.0b1</td>
<td>2.2</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0227/">PEP 227</a>: Statically Nested Scopes</td>
</tr>
<tr>
<td>generators</td>
<td>2.2.0a1</td>
<td>2.3</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0255/">PEP 255</a>: Simple Generators</td>
</tr>
<tr>
<td>division</td>
<td>2.2.0a2</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0238/">PEP 238</a>: Changing the Division Operator</td>
</tr>
<tr>
<td>absolute_import</td>
<td>2.5.0a1</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0328/">PEP 328</a>: Imports: Multi-Line and Absolute/Relative</td>
</tr>
<tr>
<td>with_statement</td>
<td>2.5.0a1</td>
<td>2.6</td>
<td><a href="http://www.python.org/dev/peps/pep-0343">PEP 343</a>: The “with” Statement</td>
</tr>
<tr>
<td>print_function</td>
<td>2.5.0a2</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-3105/">PEP 3105</a>: Make print a function</td>
</tr>
<tr>
<td>unicode_literals</td>
<td>2.5.0a2</td>
<td>3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-3112/">PEP 3112</a>: Bytes literals in Python 3000</td>
</tr>
</tbody>
</table>
<p>(Source: <a href="https://docs.python.org/2/library/future.html">https://docs.python.org/2/library/future.html</a>)</p>
<pre><code>from platform import python_version
</code></pre>
<h2 id="print函数"><strong>print函数</strong></h2>
<p>很琐碎，而 <code>print</code> 语法的变化可能是最广为人知的了，但是仍值得一提的是： Python 2 的 print 声明已经被 <code>print()</code> 函数取代了，这意味着我们必须包装我们想打印在小括号中的对象。
Python 2 不具有额外的小括号问题。但对比一下，如果我们按照 Python 2 的方式不使用小括号调用 <code>print</code> 函数，Python 3 将抛出一个语法异常（<code>SyntaxError</code>）。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print 'Hello, World!'
print('Hello, World!')
print &quot;text&quot;, ; print 'print more text on the same line'
</code></pre>
<p><em>run result:</em>
Python 2.7.6
Hello, World!
Hello, World!
text print more text on the same line</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('Hello, World!')
print(&quot;some text,&quot;, end=&quot;&quot;) 
print(' print more text on the same line')
</code></pre>
<p><em>run result:</em>
Python 3.4.1
Hello, World!
some text, print more text on the same line</p>
<pre><code>print 'Hello, World!'
</code></pre>
<p><em>run result:</em>
File ““, line 1
　　print ‘Hello, World!’
　　　　　　　　　　^
SyntaxError: invalid syntax</p>
<p><strong>Note:</strong>
　　以上通过 Python 2 使用 <code>Printing &quot;Hello, World&quot;</code> 是非常正常的，尽管如此，如果你有多个对象在小括号中，我们将创建一个元组，因为 <code>print</code> 在 Python 2 中是一个声明，而不是一个函数调用。</p>
<pre><code>print 'Python', python_version()
print('a', 'b')
print 'a', 'b'
</code></pre>
<p><em>run result:</em>
Python 2.7.7
(‘a’, ‘b’)
a b</p>
<h2 id="整除"><strong>整除</strong></h2>
<p>如果你正在移植代码，这个变化是特别危险的。或者你在 Python 2 上执行 Python 3 的代码。因为这个整除的变化表现在它会被忽视（即它不会抛出语法异常）。
　　因此，我还是倾向于使用一个 <code>float(3)/2</code> 或 <code>3/2.0</code> 代替在我的 Python 3 脚本保存在 Python 2 中的 <code>3/2</code> 的一些麻烦（并且反而过来也一样，我建议在你的 Python 2 脚本中使用 <code>from __future__ import division</code>）
<strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print '3 / 2 =', 3 / 2
print '3 // 2 =', 3 // 2
print '3 / 2.0 =', 3 / 2.0
print '3 // 2.0 =', 3 // 2.0
</code></pre>
<p><em>run result:</em>
Python 2.7.6
3 / 2 = 1
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('3 / 2 =', 3 / 2)
print('3 // 2 =', 3 // 2)
print('3 / 2.0 =', 3 / 2.0)
print('3 // 2.0 =', 3 // 2.0)
</code></pre>
<p><em>run result:</em>
Python 3.4.1
3 / 2 = 1.5
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0</p>
<h2 id="unicode"><strong>Unicode</strong></h2>
<p>Python 2 有 ASCII str() 类型，<code>unicode()</code> 是单独的，不是 <code>byte</code> 类型。
　　现在， 在 Python 3，我们最终有了 <code>Unicode (utf-8)</code> 字符串，以及一个字节类：<code>byte</code> 和 <code>bytearrays</code>。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
</code></pre>
<p><em>run result:</em>
Python 2.7.6</p>
<pre><code>print type(unicode('this is like a python3 str type'))
</code></pre>
<p><em>run result:</em>
&lt; type ‘unicode’ &gt;</p>
<pre><code>print type(b'byte type does not exist')
</code></pre>
<p><em>run result:</em>
&lt; type ‘str’ &gt;</p>
<pre><code>print 'they are really' + b' the same'
</code></pre>
<p><em>run result:</em>
they are really the same</p>
<pre><code>print type(bytearray(b'bytearray oddly does exist though'))
</code></pre>
<p><em>run result:</em>
&lt; type ‘bytearray’ &gt;</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('strings are now utf-8 \u03BCnico\u0394é!')
</code></pre>
<p><em>run result:</em>
Python 3.4.1
strings are now utf-8 μnicoΔé!</p>
<pre><code>print('Python', python_version(), end=&quot;&quot;)
print(' has', type(b' bytes for storing data'))
</code></pre>
<p><em>run result:</em>
Python 3.4.1 has &lt; class ‘bytes’ &gt;</p>
<pre><code>print('and Python', python_version(), end=&quot;&quot;)
print(' also has', type(bytearray(b'bytearrays')))
</code></pre>
<p><em>run result:</em>
and Python 3.4.1 also has &lt; class ‘bytearray’&gt;</p>
<pre><code>'note that we cannot add a string' + b'bytes for data'
</code></pre>
<p><em>run result:</em>
-—————————————————————————————————————
TypeError Traceback (most recent call last)
&lt; ipython-input-13-d3e8942ccf81&gt; in &lt; module&gt;()
——&gt; 1 ‘note that we cannot add a string’ + b’bytes for data’</p>
<p>TypeError: Can’t convert ‘bytes’ object to str implicitly</p>
<h2 id="xrange模块"><strong>xrange模块</strong></h2>
<p>在 Python 2 中 <code>xrange()</code> 创建迭代对象的用法是非常流行的。比如： <code>for</code> 循环或者是列表/集合/字典推导式。
　　这个表现十分像生成器（比如。“惰性求值”）。但是这个 <code>xrange-iterable</code> 是无穷的，意味着你可以无限遍历。
　　由于它的惰性求值，如果你不得仅仅不遍历它一次，<code>xrange()</code> 函数 比 <code>range()</code> 更快（比如 <code>for</code> 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。
　　在 Python 3 中，<code>range()</code> 是像 <code>xrange()</code> 那样实现以至于一个专门的 <code>xrange()</code> 函数都不再存在（在 Python 3 中 <code>xrange()</code> 会抛出命名异常）。</p>
<pre><code>import timeit
n = 10000
def test_range(n):
    return for i in range(n):
        pass
def test_xrange(n):
    for i in xrange(n):
        pass
</code></pre>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print '\ntiming range()'
%timeit test_range(n)
print '\n\ntiming xrange()'
%timeit test_xrange(n)
</code></pre>
<p><em>run result:</em>
Python 2.7.6</p>
<p>timing range()
1000 loops, best of 3: 433 µs per loop</p>
<p>timing xrange()
1000 loops, best of 3: 350 µs per loop</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print('\ntiming range()')
%timeit test_range(n)
</code></pre>
<p><em>run result:</em>
Python 3.4.1</p>
<p>timing range()
1000 loops, best of 3: 520 µs per loop</p>
<pre><code>print(xrange(10))
</code></pre>
<p><em>run result:</em>
-—————————————————————————————————————
NameError Traceback (most recent call last)</p>
<p>in ()
——&gt; 1 print(xrange(10))</p>
<p>NameError: name ‘xrange’ is not defined</p>
<h2 id="python3中的range对象的__contains__方法"><strong>Python3中的range对象的__contains__方法</strong></h2>
<p>另外一件值得一提的事情就是在 Python 3 中 <code>range</code> 有一个新的 <code>__contains__</code> 方法（感谢 Yuchen Ying 指出了这个），<code>__contains__</code> 方法可以加速 “查找” 在 Python 3.x 中显著的整数和布尔类型。</p>
<pre><code>x = 10000000
def val_in_range(x, val):
    return val in range(x)
def val_in_xrange(x, val):
    return val in xrange(x)
print('Python', python_version())
assert(val_in_range(x, x/2) == True)
assert(val_in_range(x, x//2) == True)
%timeit val_in_range(x, x/2)
%timeit val_in_range(x, x//2)
</code></pre>
<p><em>run result:</em>
Python 3.4.1
1 loops, best of 3: 742 ms per loop
1000000 loops, best of 3: 1.19 µs per loop
　　基于以上的 timeit 的结果，当它使一个整数类型，而不是浮点类型的时候，你可以看到执行查找的速度是 60000 倍快。尽管如此，因为 Python 2.x 的 <code>range</code> 或者是 <code>xrange</code> 没有一个 <code>__contains__</code> 方法，这个整数类型或者是浮点类型的查询速度不会相差太大。</p>
<pre><code>print 'Python', python_version()
assert(val_in_xrange(x, x/2.0) == True)
assert(val_in_xrange(x, x/2) == True)
assert(val_in_range(x, x/2) == True)
assert(val_in_range(x, x//2) == True)
%timeit val_in_xrange(x, x/2.0)
%timeit val_in_xrange(x, x/2)
%timeit val_in_range(x, x/2.0)
%timeit val_in_range(x, x/2)
</code></pre>
<p><em>run result:</em>
Python 2.7.7
1 loops, best of 3: 285 ms per loop
1 loops, best of 3: 179 ms per loop
1 loops, best of 3: 658 ms per loop
1 loops, best of 3: 556 ms per loop
　　下面说下 <code>__contain__</code>方法并没有加入到 Python 2.x 中的证据：</p>
<pre><code>print('Python', python_version())
range.__contains__
</code></pre>
<p><em>run result:</em>
Python 3.4.1</p>
<p>&lt; slot wrapper ‘<strong>contains</strong>‘ of ‘range’ objects &gt;</p>
<pre><code>print 'Python', python_version()
range.__contains__
</code></pre>
<p><em>run result:</em>
Python 2.7.7</p>
<p>-—————————————————————————————————————
AttributeError Traceback (most recent call last)
&lt; ipython-input-7-05327350dafb&gt; in &lt; module&gt;()
1 print ‘Python’, python*version()——&gt; 2 range.<code>_contains*</code></p>
<p>AttributeError: ‘builtin*functionor_method’ object has no attribute <code>’__contains*‘</code></p>
<pre><code>print 'Python', python_version()
xrange.__contains__
</code></pre>
<p><em>run result:</em>
Python 2.7.7</p>
<p>-—————————————————————————————————————
AttributeError Traceback (most recent call last)
&lt; ipython-input-8-7d1a71bfee8e&gt; in &lt; module&gt;()
1 print ‘Python’, python*version()——&gt; 2 xrange.<code>_contains*</code></p>
<p>AttributeError: type object ‘xrange’ has no attribute <code>'__contains__'</code></p>
<p><strong>注意在 Python 2 和 Python 3 中速度的不同</strong>
　　有些人指出了 Python 3 的 <code>range()</code> 和 Python 2 的 <code>xrange()</code> 之间的速度不同。因为他们是用相同的方法实现的，因此期望相同的速度。尽管如此，这事实在于 Python 3 倾向于比 Python 2 运行的慢一点。</p>
<pre><code>def test_while():
    i = 0
    while i &lt; 20000:
        i += 1
    return
</code></pre>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
%timeit test_while()
</code></pre>
<p><em>run result:</em>
Python 3.4.1
100 loops, best of 3: 2.68 ms per loop</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
%timeit test_while()
</code></pre>
<p><em>run result:</em>
Python 2.7.6
1000 loops, best of 3: 1.72 ms per loop</p>
<h2 id="raising-exceptions"><strong>Raising exceptions</strong></h2>
<p>Python 2 接受新旧两种语法标记，在 Python 3 中如果我不用小括号把异常参数括起来就会阻塞（并且反过来引发一个语法异常）。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
</code></pre>
<p><em>run result:</em>
Python 2.7.6</p>
<pre><code>raise IOError, &quot;file error&quot;
</code></pre>
<p><em>run result:</em></p>
<p>-—————————————————————————————————————
IOError Traceback (most recent call last)
&lt; ipython-input-8-25f049caebb0&gt; in &lt; module&gt;()
——&gt; 1 raise IOError, “file error”</p>
<p>IOError: file error</p>
<pre><code>raise IOError(&quot;file error&quot;)
</code></pre>
<p><em>run result:</em>
-—————————————————————————————————————
IOError Traceback (most recent call last)
&lt; ipython-input-9-6f1c43f525b2&gt; in &lt; module&gt;()
——&gt; 1 raise IOError(“file error”)</p>
<p>IOError: file error</p>
<p><strong>Python 3</strong></p>
<pre><code>print 'Python', python_version()
</code></pre>
<p><em>run result:</em>
Python 3.4.1</p>
<pre><code>raise IOError, &quot;file error&quot;
</code></pre>
<p><em>run result:</em></p>
<p>File ““, line 1
raise IOError, “file error”
　　　　　　^
SyntaxError: invalid syntax
　　在 Python 3 中，可以这样抛出异常：</p>
<pre><code>print('Python', python_version())
raise IOError(&quot;file error&quot;)
</code></pre>
<p><em>run result:</em>
Python 3.4.1</p>
<p>-—————————————————————————————————————
OSError Traceback (most recent call last)
&lt; ipython-input-11-c350544d15da&gt; in &lt; module&gt;()
1 print(‘Python’, python_version())
——&gt; 2 raise IOError(“file error”)</p>
<p>OSError: file error</p>
<h2 id="handling-exceptions"><strong>Handling exceptions</strong></h2>
<p>在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 <code>as</code> 作为关键词。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
try:
    let_us_cause_a_NameError
except NameError, err:
    print err, '--&gt; our error message'
</code></pre>
<p><em>run result:</em>
Python 2.7.6
name ‘let_us_cause_a_NameError’ is not defined —&gt; our error message</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
try:
    let_us_cause_a_NameError
except NameError as err:
    print(err, '--&gt; our error message')
</code></pre>
<p><em>run result:</em></p>
<p>Python 3.4.1
name ‘let_us_cause_a_NameError’ is not defined —&gt; our error message</p>
<h2 id="next函数-and-next方法"><strong>next()函数 and .next()方法</strong></h2>
<p>因为 <code>next() (.next())</code> 是一个如此普通的使用函数（方法），这里有另外一个语法改变（或者是实现上改变了），值得一提的是：在 Python 2.7.5 中函数和方法你都可以使用，<code>next()</code> 函数在 Python 3 中一直保留着（调用 <code>.next()</code> 抛出属性异常）。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
my_generator = (letter for letter in 'abcdefg')
next(my_generator)
my_generator.next()
</code></pre>
<p><em>run result:</em>
Python 2.7.6</p>
<p>‘b</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
my_generator = (letter for letter in 'abcdefg')
next(my_generator)
</code></pre>
<p><em>run result:</em>
Python 3.4.1</p>
<p>‘a’</p>
<pre><code>my_generator.next()
</code></pre>
<p><em>run result:</em>
-—————————————————————————————————————
AttributeError Traceback (most recent call last)
&lt; ipython-input-14-125f388bb61b&gt; in &lt; module&gt;()
——&gt; 1 my_generator.next()</p>
<p>AttributeError: ‘generator’ object has no attribute ‘next’</p>
<h2 id="for循环变量和全局命名空间泄漏"><strong>For循环变量和全局命名空间泄漏</strong></h2>
<p>好消息：在 Python 3.x 中 <code>for</code> 循环变量不会再导致命名空间泄漏。
　　在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：
　　“列表推导不再支持 <code>[... for var in item1, item2, ...]</code> 这样的语法。使用 <code>[... for var in (item1, item2, ...)]</code> 代替。也需要提醒的是列表推导有不同的语义： 他们关闭了在 <code>list()</code> 构造器中的生成器表达式的语法糖, 并且特别是循环控制变量不再泄漏进周围的作用范围域.”</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
i = 1
print 'before: i =', i
print 'comprehension: ', [i for i in range(5)]
print 'after: i =', i
</code></pre>
<p><em>run result:</em>
Python 2.7.6
before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 4</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
i = 1
print('before: i =', i)
print('comprehension:', [i for i in range(5)])
print('after: i =', i)
</code></pre>
<p><em>run result:</em>
Python 3.4.1
before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 1</p>
<h2 id="比较不可排序类型"><strong>比较不可排序类型</strong></h2>
<p>在 Python 3 中的另外一个变化就是当对不可排序类型做比较的时候，会抛出一个类型错误。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version()
print &quot;[1, 2] &gt; 'foo' = &quot;, [1, 2] &gt; 'foo'
print &quot;(1, 2) &gt; 'foo' = &quot;, (1, 2) &gt; 'foo'
print &quot;[1, 2] &gt; (1, 2) = &quot;, [1, 2] &gt; (1, 2)
</code></pre>
<p><em>run result:</em>
Python 2.7.6
[1, 2] &gt; ‘foo’ = False
(1, 2) &gt; ‘foo’ = True
[1, 2] &gt; (1, 2) = False</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print(&quot;[1, 2] &gt; 'foo' = &quot;, [1, 2] &gt; 'foo')
print(&quot;(1, 2) &gt; 'foo' = &quot;, (1, 2) &gt; 'foo')
print(&quot;[1, 2] &gt; (1, 2) = &quot;, [1, 2] &gt; (1, 2))
</code></pre>
<p><em>run result:</em>
Python 3.4.1</p>
<p>-—————————————————————————————————————
TypeError Traceback (most recent call last)
&lt; ipython-input-16-a9031729f4a0&gt; in &lt; module&gt;()
1 print(‘Python’, python_version())
——&gt; 2 print(“[1, 2] &gt; ‘foo’ = “, [1, 2] &gt; ‘foo’)
3 print(“(1, 2) &gt; ‘foo’ = “, (1, 2) &gt; ‘foo’)
4 print(“[1, 2] &gt; (1, 2) = “, [1, 2] &gt; (1, 2))</p>
<p>TypeError: unorderable types: list() &gt; str()</p>
<h2 id="通过input解析用户的输入"><strong>通过input()解析用户的输入</strong></h2>
<p>幸运的是，在 Python 3 中已经解决了把用户的输入存储为一个 <code>str</code> 对象的问题。为了避免在 Python 2 中的读取非字符串类型的危险行为，我们不得不使用 <code>raw_input()</code> 代替。</p>
<p><strong>Python 2</strong>
Python 2.7.6
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
Type “help”, “copyright”, “credits” or “license” for more information.</p>
<pre><code>&gt;&gt;&gt; my_input = input('enter a number: ')

enter a number: 123

&gt;&gt;&gt; type(my_input)
&lt;type 'int'&gt;

&gt;&gt;&gt; my_input = raw_input('enter a number: ')

enter a number: 123

&gt;&gt;&gt; type(my_input)
&lt;type 'str'&gt;

</code></pre>
<p><strong>Python 3</strong>
Python 3.4.1
[GCC 4.2.1 (Apple Inc. build 5577)] on darwin
Type “help”, “copyright”, “credits” or “license” for more information.</p>
<pre><code>&gt;&gt;&gt; my_input = input('enter a number: ')

enter a number: 123

&gt;&gt;&gt; type(my_input)
&lt;class 'str'&gt;

</code></pre>
<h2 id="返回可迭代对象而不是列表"><strong>返回可迭代对象，而不是列表</strong></h2>
<p>如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 — 代替 Python 2 中的列表
　　因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 —- 如需要遍历多次。它是不那么高效的。
　　而对于那些情况下，我们真正需要的是列表对象，我们可以通过 <code>list()</code> 函数简单的把迭代对象转换成一个列表。</p>
<p><strong>Python 2</strong></p>
<pre><code>print 'Python', python_version() 
print range(3) 
print type(range(3))
</code></pre>
<p><em>run result:</em>
Python 2.7.6
[0, 1, 2]
&lt; type ‘list’&gt;</p>
<p><strong>Python 3</strong></p>
<pre><code>print('Python', python_version())
print(range(3))
print(type(range(3)))
print(list(range(3)))
</code></pre>
<p><em>run result:</em>
Python 3.4.1
range(0, 3)
&lt; class ‘range’&gt;
[0, 1, 2]
　　在 Python 3 中一些经常使用到的不再返回列表的函数和方法：</p>
<ul>
<li><code>zip()</code></li>
<li><code>map()</code></li>
<li><code>filter()</code></li>
<li>dictionary’s <code>.keys()</code> method</li>
<li>dictionary’s <code>.values()</code> method</li>
<li>dictionary’s <code>.items()</code> method</li>
</ul>
<h2 id="更多的关于-python-2-和-python-3-的文章"><strong>更多的关于 Python 2 和 Python 3 的文章</strong></h2>
<p>下面是我建议后续的关于 Python 2 和 Python 3 的一些好文章。</p>
<p><strong>移植到 Python 3</strong></p>
<ul>
<li><a href="https://wiki.python.org/moin/Python2orPython3">Should I use Python 2 or Python 3 for my development activity?</a></li>
<li><a href="https://docs.python.org/3.0/whatsnew/3.0.html">What’s New In Python 3.0</a></li>
<li><a href="http://python3porting.com/differences.html">Porting to Python 3</a></li>
<li><a href="https://docs.python.org/3/howto/pyporting.html">Porting Python 2 Code to Python 3</a></li>
<li><a href="http://nothingbutsnark.svbtle.com/my-view-on-the-current-state-of-python-3">How keep Python 3 moving forward</a></li>
</ul>
<p><strong>Python 3 的拥护者和反对者</strong></p>
<ul>
<li><a href="http://asmeurer.github.io/python3-presentation/slides.html#1">10 awesome features of Python that you can’t use because you refuse to upgrade to Python 3</a></li>
<li><a href="http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/">Everything you did not want to know about Unicode in Python 3</a></li>
<li><a href="https://medium.com/@deliciousrobots/5d2ad703365dverything-about-unicode/">Python 3 is killing Python</a></li>
<li><a href="https://medium.com/@opinionbreaker/python-3-can-revive-python-2a7af4788b10">Python 3 can revive Python</a></li>
<li><a href="http://sealedabstract.com/rants/python-3-is-fine/">Python 3 is fine</a></li>
</ul>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="http://wangqunsong.top/post/python-xue-xi-bi-ji-08_-ling-ren-tou-teng-de-zi-fu-bian-ma">
              <h3 class="post-title">
                下一篇：Python学习笔记08_令人头疼的字符编码
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">小小王的后花园</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
